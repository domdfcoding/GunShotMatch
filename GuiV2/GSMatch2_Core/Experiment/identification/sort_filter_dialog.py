#  !/usr/bin/env python
#   -*- coding: utf-8 -*-
#
#  sort_filter_dialog.py
#
"""
Dialogs for configuring filters and sorting for IdentificationPanels
"""
#
#  This file is part of GunShotMatch
#
#  Copyright Â© 2020 Dominic Davis-Foster <dominic@davis-foster.co.uk>
#
#  GunShotMatch is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 3 of the License, or
#  (at your option) any later version.
#
#  GunShotMatch is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#  MA 02110-1301, USA.
#
#
# generated by wxGlade 0.9.3 on Tue Feb  4 15:39:04 2020
#

# stdlib
import wx

# this package
from .constants import *
from GuiV2.GSMatch2_Core.utils import create_button


class SortFilterDialog(wx.Dialog):
	def __init__(
			self, parent, id=wx.ID_ANY, title="Sort & Filter",
			pos=wx.DefaultPosition, size=(500, 360), style=0,
			name="SortFilterDialog"
			):
		"""
		TODO: Surely the reset button should call the parent's default_filter_settings
		 function and then load the new values?
		
		:param parent: Can be None, a frame or another dialog box.
		:type parent: wx.Window
		:param id: An identifier for the dialog. A value of -1 is taken to mean a default.
		:type id: wx.WindowID
		:param title: The title of the dialog.
		:type title: str
		:param pos: The dialog position. The value DefaultPosition indicates a default position,
			chosen by either the windowing system or wxWidgets, depending on platform.
		:type pos: wx.Point
		:param size: The dialog size. The value DefaultSize indicates a default size,
			chosen by either the windowing system or wxWidgets, depending on platform.
		:type size: wx.Size
		:param style: The window style.
		:type style: int
		:param name: Used to associate a name with the window, allowing the
		application user to set Motif resource values for individual dialog boxes.
		:type name: str
		"""
			
		wx.Dialog.__init__(
				self, parent, id=id, title=title, pos=pos, size=size,
				style=style | wx.DEFAULT_DIALOG_STYLE, name=name)

		self._do_layout()
		self.SetSize(size)
		
		# Populate the settings
		self.load_settings()
	
	def create_main_panel(self):
		self.main_panel = wx.Panel(self)
		
		grid_sizer_1 = wx.FlexGridSizer(3, 2, 5, 10)
		
		grid_sizer_1.Add(self.create_sort_peaks_sizer(), 1, wx.EXPAND | wx.TOP, 3)
		grid_sizer_1.Add(self.create_sort_hits_sizer(), 1, wx.EXPAND | wx.TOP, 3)
		grid_sizer_1.Add(self.create_filter_rt_sizer(), 1, wx.EXPAND, 0)
		grid_sizer_1.Add(self.create_min_hits_sizer(), 1, wx.EXPAND, 0)
		grid_sizer_1.Add(self.create_filter_area_sizer(), 1, wx.EXPAND, 0)
		grid_sizer_1.Add(self.create_min_mf_sizer(), 1, wx.EXPAND, 0)
		
		self.main_panel.SetSizer(grid_sizer_1)
		return self.main_panel
	
	# Sort Peaks
	def create_sort_peaks_sizer(self):
		peaks_sort_by_sizer = make_vertical_staticbox(self.main_panel, label="Sort Peaks By: ")
		
		peaks_sort_by_grid = wx.GridSizer(3, 1, 0, 2)
		
		kwargs = dict(parent=self.main_panel, sizer=peaks_sort_by_grid)
		
		self.sort_rt = make_radiobutton(
				**kwargs, id=ID_Sort_RT, label="Retention Time", style=wx.RB_GROUP, value=1,
				tooltip="Sort the Peaks by their retention times")
		
		self.sort_area = make_radiobutton(
				**kwargs, id=ID_Sort_Area, label="Peak Area", tooltip="Sort the Peaks by their areas")
		
		peaks_sort_by_sizer.Add(peaks_sort_by_grid, 1, wx.EXPAND, 0)
		
		self.peak_descending_check = make_descending_checkbox(self.main_panel, sizer=peaks_sort_by_sizer)
		
		return peaks_sort_by_sizer
	
	def set_peak_sort(self, by, descending=False):
		"""
		Set the criteria to sort the peaks by
		
		:param by: The criteria to sort the peaks by
		:type by: wx.WindowID
		:param descending: Whether the peaks should be sorted in descending order
		:type descending: bool
		"""
		
		self.peak_descending_check.SetValue(descending)
		
		if by == Sort_RT:
			self.sort_rt.SetValue(1)
		elif by == Sort_Area:
			self.sort_area.SetValue(1)
		else:
			raise ValueError("Unknown criteria")
	
	def get_peak_sort(self):
		
		descending = self.peak_descending_check.GetValue()
		
		if self.sort_rt.GetValue():
			return Sort_RT, descending
		elif self.sort_area.GetValue():
			return Sort_Area, descending
		
		else:
			return None, descending
	
	# Sort Hits
	def create_sort_hits_sizer(self):
		sort_hits_box = make_vertical_staticbox(self.main_panel, label="Sort Hits By: ")
		hits_sort_by_grid = wx.GridSizer(3, 2, 0, 2)
		
		kwargs = dict(parent=self.main_panel, sizer=hits_sort_by_grid)
		
		self.sort_num = make_radiobutton(
				**kwargs, id=ID_Sort_Hit, label="Hit Number", style=wx.RB_GROUP,
				tooltip="Sort the hits by their hit number", value=1)
		
		self.sort_name = make_radiobutton(
				**kwargs, id=ID_Sort_Name, label="Name", margin=False, tooltip="Sort the hits by their name")

		self.sort_mf = make_radiobutton(
				**kwargs, id=ID_Sort_MF, label="Match Factor", tooltip="Sort the hits by their match factor")
		
		self.sort_cas = make_radiobutton(
				**kwargs, id=ID_Sort_CAS, label="CAS Number", margin=False, tooltip="Sort the hits by their CAS number")
		
		self.sort_rmf = make_radiobutton(
				**kwargs, id=ID_Sort_RMF, label="Reverse Match Factor",
				tooltip="Sort the hits by their reverse match factor")
		
		sort_hits_box.Add(hits_sort_by_grid, 1, wx.EXPAND, 0)
		
		self.hit_descending_check = make_descending_checkbox(self.main_panel, sizer=sort_hits_box)
		return sort_hits_box
	
	def set_hit_sort(self, by, descending=False):
		"""
		Set the criteria to sort the hits by
		
		:param by: The criteria to sort the hits by
		:type by: wx.WindowID
		:param descending: Whether the hits should be sorted in descending order
		:type descending: bool
		"""
		
		self.hit_descending_check.SetValue(descending)
		
		if by == Sort_Hit:
			self.sort_num.SetValue(1)
		elif by == Sort_Name:
			self.sort_name.SetValue(1)
		elif by == Sort_MF:
			self.sort_mf.SetValue(1)
		elif by == Sort_RMF:
			self.sort_rmf.SetValue(1)
		elif by == Sort_CAS:
			self.sort_cas.SetValue(1)
		else:
			raise ValueError("Unknown criteria")
	
	def get_hit_sort(self):
		
		descending = self.hit_descending_check.GetValue()
		
		if self.sort_num.GetValue():
			return Sort_Hit, descending
		elif self.sort_name.GetValue():
			return Sort_Name, descending
		elif self.sort_mf.GetValue():
			return Sort_MF, descending
		elif self.sort_rmf.GetValue():
			return Sort_RMF, descending
		elif self.sort_cas.GetValue():
			return Sort_CAS, descending
		else:
			return None, descending
	
	# Sort Settings
	def _load_sort_settings(self):
		self.set_peak_sort(self.Parent.peak_sort, self.Parent.peak_descending)
		self.set_hit_sort(self.Parent.hit_sort, self.Parent.hit_descending)

	def _apply_sort_settings(self):
		self.Parent.peak_sort, self.Parent.peak_descending = self.get_peak_sort()
		self.Parent.hit_sort, self.Parent.hit_descending = self.get_hit_sort()

	def _reset_sort_settings(self):
		self.set_peak_sort(Sort_RT, False)
		self.set_hit_sort(Sort_Hit, False)

	# Filter RT
	def create_filter_rt_sizer(self):
		peaks_rt_box = make_vertical_staticbox(self.main_panel, label="Filter By Retention Time: ")
		peaks_rt_grid = wx.FlexGridSizer(2, 2, 5, 2)
		
		def create_rt_spinctrl(mode):
			return self._labelled_spinctrl_factory(
					self.main_panel, peaks_rt_grid, f"{mode}: ",
					f"Show only peaks {'after' if mode == 'Min' else 'before'} this time",
					self.on_rt_change)
		
		self.min_rt_value = create_rt_spinctrl("Min")
		self.max_rt_value = create_rt_spinctrl("Max")
		
		peaks_rt_box.Add(peaks_rt_grid, 0, wx.ALL, 2)
		return peaks_rt_box
	
	def _load_rt_settings(self):
		min_rt = calculate_min_rt(self.Parent.min_rt)
		filter_min_rt = calculate_min_rt(self.Parent.filter_min_rt)
		max_rt = calculate_min_rt(self.Parent.max_rt)
		filter_max_rt = calculate_min_rt(self.Parent.filter_max_rt)
		
		self.min_rt_value.SetMin(min_rt)
		self.max_rt_value.SetMin(min_rt)
		self.min_rt_value.SetMax(max_rt)
		self.max_rt_value.SetMax(max_rt)
		self.min_rt_value.SetValue(filter_min_rt)
		self.max_rt_value.SetValue(filter_max_rt)
	
	def _apply_rt_settings(self):
		self.Parent.filter_min_rt = self.min_rt_value.GetValue() * 60
		self.Parent.filter_max_rt = self.max_rt_value.GetValue() * 60
	
	def _reset_rt_settings(self):
		min_rt = calculate_min_rt(self.Parent.min_rt)
		max_rt = calculate_max_rt(self.Parent.max_rt)
		
		self.min_rt_value.SetValue(min_rt)
		self.max_rt_value.SetValue(max_rt)
	
	def on_rt_change(self, event):
		"""
		Event handler for RT range values being changed, to check that the maximum range is
		greater than the minimum range and vice versa, and adjust as necessary

		:param event:
		:type event:
		"""
		
		min_rt_changed = event.GetEventObject() == self.min_rt_value
		max_rt_changed = event.GetEventObject() == self.max_rt_value
		
		min_rt_value = self.min_rt_value.GetValue()
		max_rt_value = self.max_rt_value.GetValue()
		
		if min_rt_changed and min_rt_value > max_rt_value:
			self.max_rt_value.SetValue(max_rt_value + 1)
		
		elif max_rt_changed and min_rt_value > max_rt_value:
			self.min_rt_value.SetValue(min_rt_value - 1)
	
	# Filter Peak Area
	def create_filter_area_sizer(self):
		peaks_area_box = make_vertical_staticbox(self.main_panel, label="Filter By Peak Area: ")
		
		peaks_area_grid = wx.FlexGridSizer(2, 2, 5, 2)
		
		def create_area_spinctrl(mode):
			return self._labelled_spinctrl_factory(
					self.main_panel, peaks_area_grid, f"{mode}: ",
					f"Show only peaks with a {'greater' if mode == 'Min' else 'smaller'} area than this",
					self.on_area_change, (200, 29), 2)
		
		self.min_area_value = create_area_spinctrl("Min")
		self.max_area_value = create_area_spinctrl("Max")
		
		peaks_area_box.Add(peaks_area_grid, 0, wx.ALL, 2)
		return peaks_area_box
	
	def _load_area_settings(self):
		self.min_area_value.SetMin(self.Parent.min_area)
		self.max_area_value.SetMin(self.Parent.min_area)
		self.min_area_value.SetMax(self.Parent.max_area)
		self.max_area_value.SetMax(self.Parent.max_area)
		self.min_area_value.SetValue(self.Parent.filter_min_area)
		self.max_area_value.SetValue(self.Parent.filter_max_area)
		self.min_area_value.SetIncrement(1000.0)
		self.max_area_value.SetIncrement(1000.0)
	
	def _apply_area_settings(self):
		self.Parent.filter_min_area = self.min_area_value.GetValue()
		self.Parent.filter_max_area = self.max_area_value.GetValue()
	
	def _reset_area_settings(self):
		self.min_area_value.SetValue(self.Parent.min_area)
		self.max_area_value.SetValue(self.Parent.max_area)
	
	def on_area_change(self, event):
		"""
		Event handler for RT range values being changed, to check that the maximum range is
		greater than the minimum range and vice versa, and adjust as necessary

		:param event:
		:type event:
		"""
		
		min_area_changed = event.GetEventObject() == self.min_area_value
		max_area_changed = event.GetEventObject() == self.max_area_value
		
		min_area_value = self.min_area_value.GetValue()
		max_area_value = self.max_area_value.GetValue()
		
		if min_area_changed and min_area_value > max_area_value:
			self.max_area_value.SetValue(max_area_value + 1)
		
		elif max_area_changed and min_area_value > max_area_value:
			self.min_area_value.SetValue(min_area_value - 1)

	# Min Hits
	def create_min_hits_sizer(self):
		self.n_hits_check = wx.CheckBox(self.main_panel, label="Enable")
		self.Bind(wx.EVT_CHECKBOX, self.on_toggle_n_hits, self.n_hits_check)
		
		self.n_hits_value = wx.SpinCtrlDouble(self.main_panel, value="0.0", min=0.0, max=50.0)
		self.n_hits_value.Enable(False)
		self.n_hits_value.SetDigits(0)
		
		tooltip = "Show only hits up to this value. Note that this is applied before filtering by match factor."
		for widget in {self.n_hits_check, self.n_hits_value}:
			widget.SetMinSize((-1, 29))
			widget.SetToolTip(tooltip)

		n_hits_box = make_vertical_staticbox(self.main_panel, label="Number of Hits: ")
		n_hits_box.Add(self.n_hits_check, 0, wx.LEFT | wx.RIGHT | wx.TOP, 2)
		n_hits_box.Add((20, 5), 0, 0, 0)
		n_hits_box.Add(self.n_hits_value, 0, wx.BOTTOM | wx.LEFT | wx.RIGHT, 7)
		
		return n_hits_box
	
	def _load_n_hits_settings(self):
		self.n_hits_check.SetValue(self.Parent.n_hits)
		self.n_hits_value.Enable(self.Parent.n_hits)
		self.n_hits_value.SetValue(self.Parent.n_hits)

	def _apply_n_hits_settings(self):
		if self.n_hits_check.GetValue():
			self.Parent.n_hits = int(self.n_hits_value.GetValue())
		else:
			self.Parent.n_hits = 0

	def _reset_n_hits_settings(self):
		self.n_hits_check.SetValue(0)
		self.n_hits_value.SetValue(0)
		self.n_hits_value.Disable()
	
	def on_toggle_n_hits(self, event):
		self.n_hits_value.Enable(self.n_hits_check.GetValue())
		event.Skip()

	# Min Match Factor
	def create_min_mf_sizer(self):
		hits_match_box = make_vertical_staticbox(self.main_panel, label="Minimum Match Factor: ")
		hits_match_grid = wx.FlexGridSizer(2, 2, 5, 2)
		
		def create_mf_spinctrl(reverse=False):
			spinctrl = self._labelled_spinctrl_factory(
					self.main_panel, hits_match_grid, f"{'R ' if reverse else ''}Match: ",
					f"Show only hits with a {'reverse ' if reverse else ''}match factor higher than this value",
					None, (120, 29), 0, 1000.0)
		
			spinctrl.SetIncrement(10.0)
			return spinctrl
		
		self.min_mf_value = create_mf_spinctrl()
		self.min_rmf_value = create_mf_spinctrl(reverse=True)
		
		hits_match_box.Add(hits_match_grid, 0, wx.ALL, 2)
		return hits_match_box
	
	def _load_mf_settings(self):
		# Min MF and RMF
		self.min_mf_value.SetValue(self.Parent.min_mf)
		self.min_rmf_value.SetValue(self.Parent.min_rmf)

	def _apply_mf_settings(self):
		self.Parent.min_mf = self.min_mf_value.GetValue()
		self.Parent.min_rmf = self.min_rmf_value.GetValue()

	def _reset_mf_settings(self):
		self.min_mf_value.SetValue(0)
		self.min_rmf_value.SetValue(0)
		
	# All Settings
	def load_settings(self):
		self._load_rt_settings()
		self._load_area_settings()
		self._load_sort_settings()
		self._load_mf_settings()
		self._load_n_hits_settings()
	
	def apply_settings(self):
		self._apply_area_settings()
		self._apply_rt_settings()
		self._apply_sort_settings()
		self._apply_mf_settings()
		self._apply_n_hits_settings()
		self.Parent._populate_tree()
		
	# Buttons
	def create_buttons_sizer(self):
		btn_sizer = wx.GridSizer(1, 4, 0, 0)
		
		self.cancel_btn = create_button(self, wx.ID_CANCEL, sizer=btn_sizer)
		self.reset_btn = create_button(self, label="Reset", handler=self.on_reset, sizer=btn_sizer)
		self.apply_btn = create_button(self, wx.ID_APPLY, handler=self.on_apply, sizer=btn_sizer)
		self.ok_btn = create_button(self, wx.ID_OK, handler=self.on_ok, sizer=btn_sizer)
		
		return btn_sizer
	
	def on_apply(self, _):
		"""
		Handler for user pressing Apply button
		"""
		
		self.apply_settings()
		# self.Parent._populate_tree()
	
	def on_ok(self, _):
		"""
		Handler for user pressing OK button
		"""
		
		self.apply_settings()
		# self.Parent._populate_tree()
		self.Show(False)
	
	def on_reset(self, event):
		self._reset_sort_settings()
		self._reset_rt_settings()
		self._reset_n_hits_settings()
		self._reset_area_settings()
		self._reset_mf_settings()
	
	# Layout
	def _do_layout(self):
		outer_sizer = wx.BoxSizer(wx.VERTICAL)
		outer_sizer.Add(self.create_main_panel(), 1, wx.EXPAND | wx.LEFT | wx.RIGHT, 10)
		outer_sizer.Add(self.create_buttons_sizer(), 1, wx.ALIGN_RIGHT | wx.RIGHT | wx.TOP, 10)
		
		# self.btns = self.CreateStdDialogButtonSizer(wx.OK | wx.APPLY | wx.CANCEL | wx.NO)
		# print(self.btns.GetChildren())
		# for child in self.btns.GetChildren():
		# 	widget = child.GetWindow()
		# 	if isinstance(widget, wx.Button):
		#
		# no_btn = self.FindWindowById(wx.ID_NO)
		# no_btn.SetLabel("&Reset")
		# print(no_btn.GetLabel())
		#
		# outer_sizer.Add(self.btns, 0, wx.ALL | wx.EXPAND, 5)
		self.SetSizer(outer_sizer)
		self.Layout()
		self.Fit()
	
	def _labelled_spinctrl_factory(
			self, panel, sizer, label='', tooltip=None, event_handler=None,
			spinctrl_size=(-1, 29), spinctrl_digits=2, spinctrl_max_val=100.0):
		"""
		
		:param panel:
		:type panel:
		:param sizer:
		:type sizer:
		:param label:
		:type label:
		:param tooltip:
		:type tooltip:
		:param event_handler:
		:type event_handler:
		:param spinctrl_size:
		:type spinctrl_size:
		:param spinctrl_digits:
		:type spinctrl_digits:
		:param spinctrl_max_val:
		:type spinctrl_max_val:
		:return:
		:rtype:
		"""
		
		label = wx.StaticText(panel, label=label)

		spinctrl = wx.SpinCtrlDouble(panel, value="0.0", min=0.0, max=spinctrl_max_val, style=wx.TE_RIGHT)
		spinctrl.SetMinSize(spinctrl_size)
		spinctrl.SetDigits(spinctrl_digits)
		
		if tooltip:
			label.SetToolTip(tooltip)
			spinctrl.SetToolTip(tooltip)
			
		if event_handler:
			self.Bind(wx.EVT_SPINCTRLDOUBLE, event_handler, spinctrl)
			self.Bind(wx.EVT_TEXT, event_handler, spinctrl)
			self.Bind(wx.EVT_TEXT_ENTER, event_handler, spinctrl)
		
		sizer.Add(label, 0, wx.ALIGN_CENTER_VERTICAL | wx.LEFT, 2)
		sizer.Add(spinctrl, 0, 0, 0)
		
		return spinctrl
	
	
def make_radiobutton(
		parent, id=wx.ID_ANY, label='', pos=wx.DefaultPosition, size=wx.DefaultSize,
		style=0, validator=wx.DefaultValidator, name=wx.RadioButtonNameStr,
		value=0, tooltip=None, margin=True, sizer=None):
	"""
	Constructs a RadioButton, setting its value and tooltip, and optionally adding it to a sizer.

	:param parent: Parent window. Must not be None.
	:type parent: wx.Window
	:param id: Checkbox identifier. The value wx.ID_ANY indicates a default value.
	:type id: wx.WindowID, optional
	:param label: Label for the radio button.
	:type label: str, optional
	:param pos: Checkbox position. If wx.DefaultPosition is specified then a default position is chosen.
	:type pos: wx.Point, optional
	:param size: Checkbox size. If wx.DefaultSize is specified then a default size is chosen.
	:type size: wx.Size, optional
	:param style: Window style. See wx.RadioButton.
	:type style: int, optional
	:param validator: Window validator.
	:type validator: wx.Validator, optional
	:param name: Window name.
	:type name: str, optional
	:param value: Whether the radio button should be checked or unchecked (default).
	:type value: bool, optional
	:param tooltip: The tooltip for the window.
	:type tooltip: str
	:param margin: Whether a margin of 2 pixels should be added to the left of the control. Default False
	:type margin: bool, optional
	:param sizer: The sizer to add the control to. If None the control will not be added to any sizer.
	:type sizer: wx.Sizer or None, optional.

	:return:
	:rtype: wx.RadioButton
	"""

	radiobutton = wx.RadioButton(parent, id, label, pos, size, style, validator, name)
	radiobutton.SetToolTip(tooltip)
	radiobutton.SetValue(value)
	
	if sizer:
		if margin:
			sizer.Add(radiobutton, 0, wx.LEFT, 2)
		else:
			sizer.Add(radiobutton)
			
	return radiobutton


def make_descending_checkbox(
		parent, id=wx.ID_ANY, pos=wx.DefaultPosition,
		size=wx.DefaultSize, style=0, validator=wx.DefaultValidator,
		name=wx.CheckBoxNameStr, sizer=None):
	"""
	Constructs a checkbox to indicate whether the sorting should be ascending (unticked) or descending,
	and optionally adds it to a sizer.
	
	:param parent: Parent window. Must not be None.
	:type parent: wx.Window
	:param id: Checkbox identifier. The value wx.ID_ANY indicates a default value.
	:type id: wx.WindowID, optional
	:param pos: Checkbox position. If wx.DefaultPosition is specified then a default position is chosen.
	:type pos: wx.Point, optional
	:param size: Checkbox size. If wx.DefaultSize is specified then a default size is chosen.
	:type size: wx.Size, optional
	:param style: Window style. See wx.CheckBox.
	:type style: int, optional
	:param validator: Window validator.
	:type validator: wx.Validator, optional
	:param name: Window name.
	:type name: str, optional
	:param sizer: The sizer to add the control to. If None the control will not be added to any sizer.
	:type sizer: wx.Sizer or None, optional.
	
	:return:
	:rtype: wx.CheckBox
	"""
	
	descending_check = wx.CheckBox(parent, id, "Descending", pos, size, style, validator, name)
	
	if sizer:
		sizer.Add(descending_check, 0, wx.BOTTOM | wx.LEFT, 2)
	
	return descending_check


def make_vertical_staticbox(
		parent, id=wx.ID_ANY, label="", pos=wx.DefaultPosition,
		size=wx.DefaultSize, style=0, name=wx.StaticBoxNameStr):
	"""
	Constructs a RadioButton, setting its value and tooltip, and optionally adding it to a sizer.

	:param parent: Parent window. Must not be None.
	:type parent: wx.Window
	:param id: Checkbox identifier. The value wx.ID_ANY indicates a default value.
	:type id: wx.WindowID, optional
	:param label: Label for the radio button.
	:type label: str, optional
	:param pos: Checkbox position. If wx.DefaultPosition is specified then a default position is chosen.
	:type pos: wx.Point, optional
	:param size: Checkbox size. If wx.DefaultSize is specified then a default size is chosen.
	:type size: wx.Size, optional
	:param style: Window style. See wx.RadioButton.
	:type style: int, optional
	:param name: Window name.
	:type name: str, optional

	:return:
	:rtype: wx.StaticBoxSizer
	"""
	
	return wx.StaticBoxSizer(wx.StaticBox(parent, id, label, pos, size, style, name), wx.VERTICAL)


class SinglePeakSortFilterDialog(SortFilterDialog):
	def __init__(
			self, parent, id=wx.ID_ANY, title="Sort & Filter",
			pos=wx.DefaultPosition, size=(385, 360), style=0,
			name="SinglePeakSortFilterDialog"
			):
		"""
		TODO: Set the minimum number of experiments the peak must be present in
		 This should update the list of peak numbers too

		:param parent: Can be None, a frame or another dialog box.
		:type parent: wx.Window
		:param id: An identifier for the dialog. A value of -1 is taken to mean a default.
		:type id: wx.WindowID
		:param title: The title of the dialog.
		:type title: str
		:param pos: The dialog position. The value DefaultPosition indicates a
			default position, chosen by either the windowing system or wxWidgets,
			depending on platform.
		:type pos: wx.Point
		:param size: The dialog size. The value DefaultSize indicates a default
			size, chosen by either the windowing system or wxWidgets, depending on
			platform.
		:type size: wx.Size
		:param style: The window style.
		:type style: int
		:param name: Used to associate a name with the window, allowing the
			application user to set Motif resource values for individual dialog boxes.
		:type name: str
		"""
		
		SortFilterDialog.__init__(self, parent, id=id, title=title, pos=pos, size=size, style=style, name=name)
	
	def create_main_panel(self):
		self.main_panel = wx.Panel(self)
		
		grid_sizer_1 = wx.FlexGridSizer(3, 1, 5, 10)
		
		grid_sizer_1.Add(self.create_sort_hits_sizer(), 1, wx.EXPAND | wx.TOP, 3)
		grid_sizer_1.Add(self.create_min_hits_sizer(), 1, wx.EXPAND, 0)
		grid_sizer_1.Add(self.create_min_mf_sizer(), 1, wx.EXPAND, 0)
		
		self.main_panel.SetSizer(grid_sizer_1)
		
		return self.main_panel
	
	# Sort Settings
	def _load_sort_settings(self):
		self.set_hit_sort(self.Parent.hit_sort, self.Parent.hit_descending)
	
	def _apply_sort_settings(self):
		self.Parent.hit_sort, self.Parent.hit_descending = self.get_hit_sort()
	
	def _reset_sort_settings(self):
		self.set_hit_sort(Sort_Hit, False)
	
	# All Settings
	def load_settings(self):
		self._load_sort_settings()
		self._load_mf_settings()
		self._load_n_hits_settings()
	
	def apply_settings(self):
		self._apply_sort_settings()
		self._apply_mf_settings()
		self._apply_n_hits_settings()
		
	# Buttons
	def on_reset(self, event):
		self._reset_sort_settings()
		self._reset_mf_settings()
		self._reset_n_hits_settings()


def calculate_max_rt(max_rt):
	"""
	Find max rt in minutes and round up to 2dp

	:param max_rt:
	:type max_rt:
	
	:return:
	:rtype:
	"""
	
	return round(max_rt / 60, 2)


def calculate_min_rt(min_rt):
	"""
	Find min rt in minutes and round down to 2dp

	:param min_rt:
	:type min_rt:

	:return:
	:rtype:
	"""

	return min_rt / 60 // 0.01 / 100

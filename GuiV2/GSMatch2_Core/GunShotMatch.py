#  !/usr/bin/env python
#   -*- coding: utf-8 -*-
#
#  GunShotMatch.py
#
#  This file is part of GunShotMatch
#
#  Copyright Â© 2019-2020 Dominic Davis-Foster <dominic@davis-foster.co.uk>
#
#  GunShotMatch is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 3 of the License, or
#  (at your option) any later version.
#
#  GunShotMatch is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#  MA 02110-1301, USA.
#
# generated by wxGlade 0.9.3 on Tue Nov 26 10:17:30 2019
#

# stdlib
import pathlib
import signal
import time
import webbrowser
from multiprocessing import Process
import sys

# 3rd party
import wx.aui as aui
import wx.grid
import wx.html
from appdirs import user_config_dir
from domdf_wxpython_tools import coming_soon, file_dialog_multiple, file_dialog_wildcard
from domdf_wxpython_tools.style_picker import colour_picker, style_picker
from pid import PidFile
from pubsub import pub

from GSMatch.data_viewer_server import app
# this package
from GSMatch.GSMatch_Core import AboutDialog
from GuiV2.GSMatch2_Core import Experiment, Project, utils
from GuiV2.GSMatch2_Core.Config import internal_config
from GuiV2.GSMatch2_Core.GUI import Notebook, ProjectNavigator, SizeReportCtrl, WorkflowPanel
from GuiV2.GSMatch2_Core.GUI.events import EVT_PROJECT_CHANGE
from GuiV2.GSMatch2_Core.GUI.export_dialog import ExportDialog
from GuiV2.GSMatch2_Core.GUI.menus import (
	GSMChartsMenu, GSMExprMenu, GSMFileMenu, GSMHelpMenu, GSMProjectMenu,
	GSMSearchMenu, GSMToolsMenu, GSMViewMenu,
	)
from GuiV2.GSMatch2_Core.GUI.toolbars import ChartToolBar, ExperimentToolBar, ExportToolBar, ProjectToolBar, ViewToolBar
from GuiV2.GSMatch2_Core.IDs import *
from GuiV2.GSMatch2_Core.pdfViewer import pdfViewer
from GuiV2.GSMatch2_Core.PreferencesDialog import PreferencesDialog
from GuiV2.icons import get_icon


class GunShotMatch(wx.Frame):
	def __init__(self, parent, id=wx.ID_ANY, pos=wx.DefaultPosition, style=0):
		"""
		:param parent: The window parent. This may be, and often is, None. If it is not None, the frame will be minimized when its parent is minimized and restored when it is restored (although it will still be possible to minimize
		:type parent: wx.Window
		:param id: The window identifier. It may take a value of -1 to indicate a default value.
		:type id: wx.WindowID, optional
		:param pos: The window position. The value DefaultPosition indicates a default position, chosen by either the windowing system or wxWidgets, depending on platform.
		:type pos: wx.Point, optional
		:param style: The window style. See wx.Frame class description.
		:type style: int, optional
		"""
		
		signal.signal(signal.SIGINT, self.sigint_handler)
		
		self._perspectives = []
		self.n = 0
		self.x = 0
		self.opened_projects = {}
		
		wx.Frame.__init__(
				self, parent, id=id, title="GunShotMatch", pos=pos, size=(1855, 1056),
				style=style | wx.DEFAULT_FRAME_STYLE, name="GunShotMatch",
				)
		# self.SetSize((1855, 1056))
		
		# Menu Bar
		self.GunShotMatch_menubar = wx.MenuBar()
		
		file_menu = GSMFileMenu(self)
		self.GunShotMatch_menubar.Append(file_menu, "File")
		
		self.menu_project = GSMProjectMenu(self)
		self.GunShotMatch_menubar.menu_project_new = self.menu_project.new_item
		self.GunShotMatch_menubar.menu_project_open = self.menu_project.open_item
		self.GunShotMatch_menubar.Append(self.menu_project, "Project")
		
		self.expr_menu = GSMExprMenu(self)
		self.GunShotMatch_menubar.Append(self.expr_menu, "Experiment")
		
		charts_menu = GSMChartsMenu(self)
		self.GunShotMatch_menubar.Append(charts_menu, "Charts")

		self.view_menu = GSMViewMenu(self)
		self.GunShotMatch_menubar.Append(self.view_menu, "View")
		
		self.search_menu = GSMSearchMenu(self)
		self.GunShotMatch_menubar.Append(self.search_menu, "Search")
		
		self.tools_menu = GSMToolsMenu(self)
		self.GunShotMatch_menubar.Append(self.tools_menu, "Tools")
		
		help_menu = GSMHelpMenu(self)
		self.GunShotMatch_menubar.Append(help_menu, "Help")
		
		self.SetMenuBar(self.GunShotMatch_menubar)
		# Menu Bar end
		
		self.GunShotMatch_statusbar = self.CreateStatusBar(2)

		self._set_properties()
		self._do_layout()

		self._bind_events()
		
		if internal_config.last_position != (-1, -1):
			self.SetPosition(internal_config.last_position)
		if internal_config.last_size != (-1, -1):
			self.SetSize(internal_config.last_size)
		if internal_config.last_maximized:
			self.Maximize()
		self.SetSize(self.GetSize())
		
		self.update_panel_checkboxes()
		self.setup_recent_menu()
		self._mgr.Update()
		
		self.pdf_handler = pdfViewer(
				self, wx.ID_ANY, wx.DefaultPosition,
				wx.DefaultSize, wx.HSCROLL | wx.VSCROLL | wx.SUNKEN_BORDER
				)
		self.pdf_handler.Hide()
		
		self.start_data_viewer_server()

	def _bind_events(self):
		# Toolbar Events
		self.Bind(wx.EVT_MENU, self.on_new_experiment, id=ID_New_Experiment_Single)
		self.Bind(wx.EVT_MENU, self.on_new_experiment_multiple, id=ID_New_Experiment_Multiple)
		# self.Bind(wx.EVT_TOOL, self.on_new_experiment, id=ID_New_Experiment)
		
		# self.Bind(wx.EVT_ERASE_BACKGROUND, self.OnEraseBackground)
		self.Bind(wx.EVT_SIZE, self.on_size)
		self.Bind(wx.EVT_CLOSE, self.OnClose)
		# self.Bind(wx.aui.EVT_AUINOTEBOOK_PAGE_CLOSED, self.on_close_project)
		
		# WorkflowPanel
		self.Bind(wx.EVT_BUTTON, self.on_quick_start_guide, self.workflow_panel.quick_start_guide_btn)
		self.Bind(wx.EVT_BUTTON, self.on_run_alignment, self.workflow_panel.alignment_btn)
		self.Bind(wx.EVT_BUTTON, self.on_run_identify, self.workflow_panel.identify_btn)
		self.Bind(wx.EVT_BUTTON, self.on_run_consolidate, self.workflow_panel.consolidate_btn)
		self.Bind(wx.EVT_BUTTON, self.on_run_analysis, self.workflow_panel.run_analysis_btn)

		# Notebook
		EVT_PROJECT_CHANGE.set_receiver(self)
		EVT_PROJECT_CHANGE.Bind(self.update_titles)
		self.Bind(aui.EVT_AUI_PANE_CLOSE, self.on_pane_close)
		
		# Export Dialog request exporting current page as PDF
		pub.subscribe(self.on_export_pdf, "export_current_pdf")
		pub.subscribe(self.on_export_project_report, "export_project_report")
		# pub.subscribe(self.on_export_images, "export_current_images")
		# pub.subscribe(self.on_export_csv, "export_current_csv")
		# TODO: above
	
		# Export Dialog request for exporting method and ammo_details files
		pub.subscribe(self.on_export_method, "export_method")
		pub.subscribe(self.on_export_ammo_details, "export_ammo_details")
		
		# Bind events for enabling and disabling controls
		pub.subscribe(self.toggle_spectrum_options, "toggle_view_tools")
		pub.subscribe(self.toggle_expr_options, "toggle_expr_tools")
		pub.subscribe(self.on_refresh_menus, "refresh_menus")
		
	def _create_toolbars(self):
		# Create Toolbars
		self.tb_project = ProjectToolBar(self)
		self.tb_experiment = ExperimentToolBar(self)
		self.tb_charts = ChartToolBar(self)
		self.tb_view = ViewToolBar(self, ID_View_Toolbar)
		self.tb_export = ExportToolBar(self, ID_View_Toolbar)
		
		# Add the toolbars to the manager
		self.tb_project.add_to_manager(self._mgr)
		self.tb_experiment.add_to_manager(self._mgr)
		self.tb_charts.add_to_manager(self._mgr)
		self.tb_view.add_to_manager(self._mgr)
		self.tb_export.add_to_manager(self._mgr)
		
		# Set the initial state of buttons
		self.tb_view.toggle_view_tools(False)
		self.tb_view.toggle_experiment_tools(False)
		self.tb_experiment.toggle_experiment_tools(False)
		
	def _set_properties(self):
		# tell FrameManager to manage this frame
		self._mgr = aui.AuiManager(flags=wx.aui.AUI_MGR_LIVE_RESIZE | wx.aui.AUI_MGR_DEFAULT)
		self._mgr.SetManagedWindow(self)
		
		self.GunShotMatch_statusbar.SetStatusWidths([-2, -3])
		
		# statusbar fields
		GunShotMatch_statusbar_fields = ["Ready", "Welcome to GunShotMatch"]
		for i in range(len(GunShotMatch_statusbar_fields)):
			self.GunShotMatch_statusbar.SetStatusText(GunShotMatch_statusbar_fields[i], i)
		
		_icon = wx.NullIcon
		_icon.CopyFromBitmap(get_icon("logo-v2", 256))
		self.SetIcon(_icon)

	def _do_layout(self):
		master_sizer = wx.BoxSizer(wx.VERTICAL)
		master_sizer.Add((0, 0), 0, 0, 0)
		self.SetSizer(master_sizer)
		self.Layout()
		
		self._create_toolbars()
		
		# self.project_navigator = self.create_project_navigator_ctrl()
		self.project_navigator = ProjectNavigator(self, wx.ID_ANY)
		
		# Project Navigator Pane on the top left
		self._mgr.AddPane(self.project_navigator, aui.AuiPaneInfo().
						  Name("Project Navigator").Left().Layer(1).Position(1).
						  Caption("Project Navigator").CloseButton(True).
						  MaximizeButton(False).BestSize((250, 800)).MinimizeButton(True)) # MinSize((250, 300))
		
		self.workflow_panel = WorkflowPanel(self, wx.ID_ANY)
		
		# Workflow Pane on the middle left
		self._mgr.AddPane(self.workflow_panel, aui.AuiPaneInfo().
						  Name("Workflow").Caption("Workflow").
						  Left().Layer(1).Position(2).CloseButton(True).MaximizeButton(False).
						  BestSize((250, 900)).MinimizeButton(True))  # MinSize((250, 100)).
		
		self.legend_panel = self.create_size_report_ctrl()
		
		# Placeholder for legend on bottom left
		self._mgr.AddPane(self.legend_panel, aui.AuiPaneInfo().
						  Name("Chart Legend").Caption("Legend Placeholder").
						  Left().Layer(1).Position(3).CloseButton(True).MaximizeButton(False).MinimizeButton(True))
		
		# Set initial sizes of panels
		self._mgr.GetPane("Project Navigator").dock_proportion = 20
		self._mgr.GetPane("Workflow").dock_proportion = 25
		self._mgr.GetPane("Chart Legend").dock_proportion = 10
		
		# Data Notebook in the center
		self.notebook = Notebook(self)
		self._mgr.AddPane(self.notebook, aui.AuiPaneInfo().Name("Data Notebook").CenterPane())
		
		# Set default perspective
		self.default_perspective = self._mgr.SavePerspective()
		self._perspectives.append(self.default_perspective)

		# Unused panes
		
		# self._mgr.AddPane(SettingsPanel(self, self), aui.AuiPaneInfo().
		# 				  Name("settings").Caption("Dock Manager Settings").
		# 				  Dockable(False).Float().Hide().CloseButton(True).MaximizeButton(True))
		
		# self._mgr.AddPane(self.create_text_ctrl(), aui.AuiPaneInfo().
		# 				  Name("test10").Caption("Text Pane").
		# 				  Bottom().Layer(1).Position(1).CloseButton(True).MaximizeButton(True))
		
		# self._mgr.AddPane(self.create_HTML_ctrl(), aui.AuiPaneInfo().Name("html_content").
		# 				  CenterPane())
		
		self._mgr.Update()
		
		self.notebook.SetTabCtrlHeight(35)
	
	def toggle_expr_options(self, enable=True):
		for tool_id in {ID_View_Spectrum_by_rt, ID_View_Spectrum_by_num}:
			self.view_menu.FindItemById(tool_id).Enable(enable)
			
		for tool_id in {ID_Next_Experiment, ID_Previous_Experiment}:
			self.expr_menu.FindItemById(tool_id).Enable(enable)
	
	def toggle_chart_options(self, enable=True):
		for tool_id in {
				ID_View_Reset, ID_View_Previous, ID_View_Default, ID_View_Zoom,
				ID_View_Pan, ID_View_Rescale_x, ID_View_Rescale_y,
				}:
			self.view_menu.FindItemById(tool_id).Enable(enable)
	
	def toggle_spectrum_options(self, enable=True):
		self.toggle_chart_options(enable)
		
		for tool_id in {ID_View_Spectrum}:
			self.view_menu.FindItemById(tool_id).Enable(enable)
	
	def toggle_remove_alignment(self, enable=True):
		self.tools_menu.FindItemById(ID_RemoveAlignmentData).Enable(enable)
	
	def toggle_remove_ident(self, enable=True):
		self.tools_menu.FindItemById(ID_RemoveIdentData).Enable(enable)
	
	def toggle_remove_consolidate(self, enable=True):
		self.tools_menu.FindItemById(ID_RemoveConsolidateData).Enable(enable)
	
	def on_refresh_menus(self):
		selected_project_panel = self.notebook.get_selected_project_panel()
		
		if selected_project_panel is None:
			# Disable all
			# self.toggle_expr_options(False)
			# self.toggle_spectrum_options(False)
			self.toggle_remove_alignment(False)
			self.toggle_remove_ident(False)
			self.toggle_remove_consolidate(False)
		else:
			# selected_expr_panel = selected_project_panel.get_selected_experiment_panel()
			#
			# self.toggle_expr_options(bool(selected_expr_panel))
			#
			# if selected_expr_panel:
			# 	self.toggle_expr_options()
			# 	expr_selected_tab = selected_expr_panel.get_selected_page()
			#
			# 	self.toggle_spectrum_options(isinstance(expr_selected_tab, Experiment.ChromatogramPanel))
			
			selected_project = selected_project_panel.project
			
			self.toggle_remove_alignment(selected_project.alignment_performed)
			self.toggle_remove_ident(any(
					experiment.identification_performed for experiment in selected_project.experiment_objects
					))
			self.toggle_remove_consolidate(selected_project.consolidate_performed)
	
	def on_pane_close(self, event):
		# Cancel closing the pane, we'll hide it later so we can open it again
		event.Veto()
		
		# Hide the pane
		event.GetPane().Show()
		self._mgr.Update()
		
		self.update_panel_checkboxes()
	
	def update_panel_checkboxes(self):
		self.GunShotMatch_menubar.Check(ID_View_Workflow, self._mgr.GetPane("Workflow").IsShown())
		self.GunShotMatch_menubar.Check(ID_View_Proj_Nav, self._mgr.GetPane("Project Navigator").IsShown())
		self.GunShotMatch_menubar.Check(ID_View_Legend, self._mgr.GetPane("Chart Legend").IsShown())
	
	def show_pane(self, pane_name, show=True):
		"""
		Show the pane with the given name

		:param pane_name:
		:type pane_name:
		:param show:
		:type show:

		:return:
		:rtype:
		"""

		if show:
			self._mgr.GetPane(pane_name).Show().Float()
		else:
			self._mgr.GetPane(pane_name).Show()
		self._mgr.Update()
		self.update_panel_checkboxes()

	def update_titles(self, event):
		self.notebook.update_titles(event)
	
	def setup_recent_menu(self):
		dropdown = self.tb_project.FindById(wx.ID_OPEN).GetDropdownMenu()
		
		for idx, ID in enumerate(recent_project_ids):
			menu_recent = self.menu_project.FindItemById(ID)
			toolbar_recent = dropdown.FindItemById(ID)
			
			label = internal_config.recent_projects[idx][1]
			if label == ".":
				menu_recent.Enable(False)
				toolbar_recent.Enable(False)
				label = f"Recent Project {idx + 1}"
			else:
				menu_recent.Enable(True)
				toolbar_recent.Enable(True)
				
			menu_recent.SetItemLabel(label)
			toolbar_recent.SetItemLabel(label)
	
	# Create Panels
	# def create_text_ctrl(self):
	#
	# 	text = ("This is text box %d") % (self.n + 1)
	#
	# 	return wx.TextCtrl(self, -1, text, wx.Point(0, 0), wx.Size(150, 90),
	# 					   wx.NO_BORDER | wx.TE_MULTILINE)
	
	# def create_grid(self):
	#
	# 	grid = wx.grid.Grid(self, -1, wx.Point(0, 0), wx.Size(150, 250),
	# 						wx.NO_BORDER | wx.WANTS_CHARS)
	#
	# 	grid.CreateGrid(50, 20)
	#
	# 	return grid
	
	def create_tree_ctrl(self):
		
		tree = wx.TreeCtrl(
				self, -1, wx.Point(0, 0), wx.Size(160, 250),
				wx.TR_DEFAULT_STYLE | wx.NO_BORDER,
				)
		
		root = tree.AddRoot("AUI Project")
		items = []
		
		imglist = wx.ImageList(16, 16, True, 2)
		imglist.Add(wx.ArtProvider.GetBitmap(wx.ART_FOLDER, wx.ART_OTHER, wx.Size(16, 16)))
		imglist.Add(wx.ArtProvider.GetBitmap(wx.ART_NORMAL_FILE, wx.ART_OTHER, wx.Size(16, 16)))
		tree.AssignImageList(imglist)
		
		items.append(tree.AppendItem(root, "Item 1", 0))
		items.append(tree.AppendItem(root, "Item 2", 0))
		items.append(tree.AppendItem(root, "Item 3", 0))
		items.append(tree.AppendItem(root, "Item 4", 0))
		items.append(tree.AppendItem(root, "Item 5", 0))
		
		for ii in range(len(items)):
			item_id = items[ii]
			tree.AppendItem(item_id, "Subitem 1", 1)
			tree.AppendItem(item_id, "Subitem 2", 1)
			tree.AppendItem(item_id, "Subitem 3", 1)
			tree.AppendItem(item_id, "Subitem 4", 1)
			tree.AppendItem(item_id, "Subitem 5", 1)
		
		tree.Expand(root)
		
		return tree
	
	def create_size_report_ctrl(self, width=80, height=80):
		
		ctrl = SizeReportCtrl(self, -1, wx.DefaultPosition, wx.Size(width, height), self._mgr)
		return ctrl
	
	# def create_HTML_ctrl(self):
	# 	ctrl = wx.html.HtmlWindow(self, -1, wx.DefaultPosition, wx.Size(400, 300))
	# 	if "gtk2" in wx.PlatformInfo or "gtk3" in wx.PlatformInfo:
	# 		ctrl.SetStandardFonts()
	# 	ctrl.SetPage("This is GunShotMatch")
	# 	return ctrl
	
	# Projects

	def on_open_project(self, _):

		filenames = file_dialog_multiple(
				self, "proj", "Open Project", "Project files",
				style=wx.FD_OPEN | wx.FD_FILE_MUST_EXIST | wx.FD_MULTIPLE,
				defaultDir=str(internal_config.last_project),
				)

		if filenames:
			for filename in filenames:
				self.open_project(filename)
	
	def open_project(self, filename):
		print(f"Opening project: {filename}")
		
		project = Project.load(filename)
		
		if project.name in self.opened_projects:
			wx.MessageBox(
				"""That Project, or a Project with the same name, is already open.
Please choose a different project.""",
				"Project Already Open", wx.ICON_ERROR | wx.OK, parent=self
				)
			return
		
		page = self.notebook.add_project(project)
		self.opened_projects[project.name] = page
		self.project_navigator.add_project(project)
		
		internal_config.last_project = filename
		internal_config.add_recent_project(project.name, filename)
		
		self.setup_recent_menu()
		
		self._mgr.Update()
		
		self.notebook.update_titles()
		
		current_project_idx = self.notebook.GetSelection()
		current_project_panel = self.notebook.GetPage(current_project_idx)
		print(f"Unsaved Changes: {current_project_panel.project.unsaved_changes}")
	
	def on_new_project(self, _):
		# TODO: do this like the new_experiment dialog, where it is not modal, including the guard code
		# TODO@ guard code could perhaps be a decorator
		with Project.NewProjectDialog(self, wx.ID_ANY) as dlg:
			if dlg.ShowModal() == wx.ID_OK:
				if dlg.filename:
					self.open_project(dlg.filename)
	
	def on_recent_project(self, event):
		clicked_id = event.Id
		
		for idx, recent_id in enumerate(recent_project_ids):
			if recent_id == clicked_id:
				self.open_project(internal_config.recent_projects[idx][1])
	
	def on_close_project(self, _):
		self.notebook.remove_project()
	
	def on_save_project(self, _):
		pub.sendMessage("SaveProject")
		self.notebook.get_selected_page().save()

	def on_save_all(self, _):
		coming_soon()
	
	def on_run_analysis(self, _):
		if self.workflow_panel.alignment_checkbox.GetValue():
			self.on_run_alignment()
		
		if self.workflow_panel.identify_checkbox.GetValue():
			self.on_run_identify()
		
		if self.workflow_panel.consolidate_checkbox.GetValue():
			self.on_run_consolidate()
		
		if self.workflow_panel.spectra_checkbox.GetValue():
			# TODO:
			pass
		
		if self.workflow_panel.charts_checkbox.GetValue():
			# TODO:
			pass
		
	def on_run_alignment(self, event=None):
		project_panel = self.notebook.get_selected_project_panel()
		if isinstance(project_panel, Project.ProjectDataPanel):
			
			print("#######")
			project_panel.align()
			print(project_panel.project.unsaved_changes)
			print("#######")
		
	def on_run_identify(self, event=None):
		print("Identifying Compounds...")
		
		project_panel = self.notebook.get_selected_project_panel()
		if isinstance(project_panel, Project.ProjectDataPanel):
			print("#######")
			project_panel.identify()
			print(project_panel.project.unsaved_changes)
			print("#######")
	
	def on_run_consolidate(self, event=None):
		print("Performing Consolidate...")
		
		project_panel = self.notebook.get_selected_project_panel()
		if isinstance(project_panel, Project.ProjectDataPanel):
			print("#######")
			project_panel.consolidate()
			# print(project_panel.project.unsaved_changes)
			print("#######")
		
	# def save_changes(self):
	# 	for project, data in self.project_navigator.project_navigator_data.items():
	# 		if project != "__root":
	# 			print(project)
	# 			print(data["project"])
	#
	# 	return True
	# 	if self.AmmunitionDetailsPanel.fileNotSaved:
	# 		while True:
	# 			with wx.MessageDialog(
	# 					self,
	# 					"Do you want to save the changes to the current Ammunition Details record?",
	# 					"Save Changes?",
	# 					wx.ICON_QUESTION | wx.YES_NO | wx.CANCEL
	# 					) as dlg:
	# 				res = dlg.ShowModal()
	#
	# 				if res == wx.ID_YES:
	# 					if self.save_record():
	# 						break
	# 				elif res == wx.ID_NO:
	# 					print("Changes discarded")
	# 					break
	# 				else:
	# 					return False
	#
	# Experiments
	
	def on_new_experiment(self, _):
		# TODO: check to see if dialog is already open
		# if hasattr(self, "new_experiment_dialog"):
		# 	# Already open
		# 	self.new_experiment_dialog.SetFocus()
		# else:
		self.new_experiment_dialog = Experiment.NewExperimentDialog(self, wx.ID_ANY)
		self.new_experiment_dialog.Show()
	
	def on_new_experiment_multiple(self, _):
		# TODO: check to see if dialog is already open
		Experiment.MultipleExperimentsDialog(self, wx.ID_ANY).Show()
	
	def on_next_experiment(self, _):
		current_selected_page = self.notebook.get_selected_page()
		current_selected_page.next_experiment()
		return
	
	def on_previous_experiment(self, _):
		current_selected_page = self.notebook.get_selected_page()
		current_selected_page.previous_experiment()
		return
		
	def switch_to_project_content(self, project, page_title):
		return self.notebook.switch_to_project_content(project, page_title)
		
	def switch_to_experiment_content(self, project, expr_name, page_title):
		return self.notebook.switch_to_experiment_content(project, expr_name, page_title)
	
	# Close Functions
	
	def OnClose(self, event):
		self.OnExit(event)
	
	def OnExit(self, event):
		internal_config.last_position = self.GetPosition()
		internal_config.last_size = self.GetSize()
		internal_config.last_maximized = self.IsMaximized()
		
		if event.ClassName == "wxCloseEvent":
			# Window's Close button clicked
			event.Veto()
		
		# Check if any projects are unsaved:
		for project_idx in range(self.notebook.GetPageCount()):
			if self.notebook.GetPageText(project_idx) == "Welcome":
				continue
				
			project_panel = self.notebook.GetPage(project_idx)
			if not project_panel.save_changes():
				return
		
		self.stop_data_viewer_server()
		
		self._mgr.UnInit()
		del self._mgr
		self.Raise()
		self.SetFocus()
		self.Destroy()
		print("Be Seeing You!")
	
	# Printing and Export
	
	def on_export(self, _):
		ExportDialog(self).Show()
	
	def on_export_pdf(self, event=None):
		# Determine the currently selected tab and ask it to export as PDF
		# TODO: Guard for welcome page
		selected_project = self.notebook.get_selected_project()
		selected_page = self.notebook.get_selected_project_panel().get_selected_page()
		
		if isinstance(selected_page, Experiment.ExperimentDataPanel):
			selected_page.export_pdf(input_filename=selected_project.filename.value)
		elif isinstance(selected_page, Project.CompoundsDataPanel):
			selected_page.export_pdf(input_filename=selected_project.filename.value)
		
		elif hasattr(selected_page, "export_pdf"):
			filename = file_dialog_wildcard(
					self,
					title="Export PDF",
					wildcard="PDF Files (*.pdf)|*.pdf;*.PDF",
					defaultDir=str(internal_config.last_export)
					)
			
			if filename:
				internal_config.last_export = filename[0]
				
				selected_page.export_pdf(
						input_filename=selected_project.filename.value,
						output_filename=filename[0]
						)
			
				time.sleep(1)
				webbrowser.open(filename[0])
		else:
			wx.MessageBox("The current page does not support exporting to PDF.", "Unsupported")
	
	def on_export_project_report(self, event=None):
		# Determine the currently selected tab and ask it to export as PDF
		selected_project_panel = self.notebook.get_selected_project_panel()
		
		if selected_project_panel:
			filename = file_dialog_wildcard(
					self,
					title="Export Project Report",
					wildcard="PDF Files (*.pdf)|*.pdf;*.PDF",
					defaultDir=str(internal_config.last_export)
					)
			
			if filename:
				internal_config.last_export = filename[0]
				
				selected_project_panel.export_project_report(output_filename=filename[0])
			
				time.sleep(1)
				webbrowser.open(filename[0])
		else:
			wx.MessageBox("The current page does not support exporting to PDF.", "Unsupported")
	
	def on_export_method(self, event=None):
		# Determine the currently selected tab and ask it to export as PDF
		selected_page = self.notebook.get_selected_page()
		
		if hasattr(selected_page, "export_method"):
			filename = file_dialog_wildcard(
					self,
					title="Export Method",
					wildcard="Method Files (*.method)|*.method;*.METHOD",
					defaultDir=str(internal_config.last_export)
					)
			
			if filename:
				internal_config.last_export = filename[0]
				
				selected_page.export_method(output_filename=filename[0])
		
		else:
			wx.MessageBox("The Method cannot be exported for the current page.", "Unsupported")
	
	def on_export_ammo_details(self, event=None):
		# Determine the currently selected tab and ask it to export as PDF
		selected_page = self.notebook.get_selected_project_panel()
		
		if hasattr(selected_page, "export_ammo_details"):
			filename = file_dialog_wildcard(
					self,
					title="Export Ammo Details",
					wildcard="ammo Files (*.ammo)|*.ammo;*.AMMO",
					defaultDir=str(internal_config.last_export)
					)
			
			if filename:
				internal_config.last_export = filename[0]
				
				selected_page.export_ammo_details(output_filename=filename[0])
		
		else:
			wx.MessageBox("The Ammo Details cannot be exported for the current page.", "Unsupported")
	
	def on_print_preview(self, _):
		# TODO
		# TODO: Guard for welcome page
		# TODO: Guard could be a decorator
		# Determine the currently selected tab and ask it to export as PDF
		selected_project = self.notebook.get_selected_project()
		selected_page = self.notebook.get_selected_project_panel().get_selected_page()
		
		if hasattr(selected_page, "print_preview"):
			selected_page.print_preview(
					input_filename=selected_project.filename.value,
					output_filename=output_filename
					)
		else:
			wx.MessageBox("The current page does not support exporting to PDF.", "Unsupported")
	
	def on_print(self, _):
		# TODO
		# TODO: Guard for welcome page
		# Determine the currently selected tab and ask it to export as PDF
		selected_project = self.notebook.get_selected_project()
		selected_page = self.notebook.get_selected_project_panel().get_selected_page()
		
		if hasattr(selected_page, "print"):
			selected_page.print(
					input_filename=selected_project.filename.value,
					output_filename=output_filename
					)
		else:
			wx.MessageBox("The current page does not support exporting to PDF.", "Unsupported")
	
	def on_printer_settings(self, _):
		# Determine the currently selected tab and ask it to print
		print(self.notebook.get_selected_project_panel().get_selected_page())
		
	# Charts
	
	def on_config_colours(self, _):
		"""
		Opens the colour_picker dialog to allow the user to choose the colours for the chart
		"""

		dlg = colour_picker(self, selection_choices=internal_config.chart_colours)
		res = dlg.ShowModal()
		if res == wx.ID_OK:
			internal_config.chart_colours = dlg.colour_list

			dlg.Destroy()
			# todo: self.replot_chart()

	def on_config_markers(self, _):
		"""
		Opens the style_picker dialog to allow the user to choose the styles for the chart
		"""
		
		dlg = style_picker(self, selection_choices=internal_config.chart_styles, title="Configure Markers")
		res = dlg.ShowModal()
		if res == wx.ID_OK:
			internal_config.chart_styles = dlg.style_list
			
			dlg.Destroy()
			# todo: self.replot_chart()
	
	def on_config_borders(self, _):
		coming_soon()
	
	# Other
	#
	# def get_dock_art(self):
	# 	return self._mgr.GetArtProvider()
	
	def on_size(self, event):
		event.Skip()
	
	def on_menu_view_restore(self, event):
		self._mgr.LoadPerspective(self.default_perspective)
		event.Skip()
	
	def on_menu_tools_settings(self, event):
		PreferencesDialog(self).Show()
		
		event.Skip()
	
	def on_menu_help_about(self, event):
		"""
		Handler for "Menu" > "About" menu entry
		"""
		
		about_dlg = AboutDialog.AboutDialog(self)
		about_dlg.ShowModal()
		about_dlg.Destroy()
		event.Skip()
	
	def on_quick_start_guide(self, event):
		print("Event handler 'on_quick_start_guide' not implemented!")
		event.Skip()
	
	def on_chart_save(self, event):
		print("Event handler 'on_chart_save' not implemented!")
		event.Skip()
	
	def on_reset_view(self, event):
		self.notebook.on_reset_view(event)
		event.Skip()
	
	def on_previous_view(self, event):
		self.notebook.on_previous_view(event)
		event.Skip()
	
	def on_rescale_y(self, event):
		self.notebook.on_rescale_y(event)
		event.Skip()
	
	def on_rescale_x(self, event):
		self.notebook.on_rescale_x(event)
		event.Skip()
	
	def on_view_select(self, _):
		self.tb_view.ToggleTool(ID_View_Default, True)
		self.tb_view.ToggleTool(ID_View_Pan, False)
		self.tb_view.ToggleTool(ID_View_Zoom, False)
		self.tb_view.ToggleTool(ID_View_Spectrum, False)
		
		self.trigger_view_mode_change()
	
	def check_tool_state(self, event, tool_id):
		return self.tb_view.GetToolState(tool_id) and not isinstance(event.GetEventObject(), wx.ToolBar)
		
	def on_zoom(self, event):
		if self.check_tool_state(event, ID_View_Zoom):
			self.tb_view.ToggleTool(ID_View_Zoom, False)
			self.tb_view.ToggleTool(ID_View_Default, True)
		else:
			self.tb_view.ToggleTool(ID_View_Default, False)
			self.tb_view.ToggleTool(ID_View_Zoom, True)
			
		self.tb_view.ToggleTool(ID_View_Pan, False)
		self.tb_view.ToggleTool(ID_View_Spectrum, False)
		
		self.trigger_view_mode_change()
		
	def on_pan(self, event):
		if self.check_tool_state(event, ID_View_Pan):
			self.tb_view.ToggleTool(ID_View_Default, True)
			self.tb_view.ToggleTool(ID_View_Pan, False)
		else:
			self.tb_view.ToggleTool(ID_View_Pan, True)
			self.tb_view.ToggleTool(ID_View_Default, False)
			
		self.tb_view.ToggleTool(ID_View_Zoom, False)
		self.tb_view.ToggleTool(ID_View_Spectrum, False)
		
		self.trigger_view_mode_change()
		
	def trigger_view_mode_change(self):
		pub.sendMessage("view_mode_changed")

	def on_spectrum_click(self, event):
		if self.check_tool_state(event, ID_View_Spectrum):
			self.tb_view.ToggleTool(ID_View_Default, True)
			self.tb_view.ToggleTool(ID_View_Spectrum, False)
		else:
			self.tb_view.ToggleTool(ID_View_Spectrum, True)
			self.tb_view.ToggleTool(ID_View_Default, False)
			
		self.tb_view.ToggleTool(ID_View_Pan, False)
		self.tb_view.ToggleTool(ID_View_Zoom, False)
		
		self.trigger_view_mode_change()
		
	def on_spectrum_scan(self, event):
		self.notebook.on_spectrum_scan(event)
		
	def on_spectrum_rt(self, event):
		self.notebook.on_spectrum_rt(event)
	
	def on_menu_help(self, event):
		print("Event handler 'on_menu_help' not implemented!")
		event.Skip()
		
	def on_toggle_workflow(self, event):
		self.show_pane("Workflow", self.GunShotMatch_menubar.IsChecked(ID_View_Workflow))
		event.Skip()
		
	def on_toggle_project_navigator(self, event):
		self.show_pane("Project Navigator", self.GunShotMatch_menubar.IsChecked(ID_View_Proj_Nav))
		event.Skip()
		
	def on_toggle_legend(self, event):
		self.show_pane("Chart Legend", self.GunShotMatch_menubar.IsChecked(ID_View_Legend))
		event.Skip()
	
	def on_menu_remove_ident(self, event):
		choices = [label for label in self.project_navigator.project_navigator_data.keys() if label != "__root"]
		print(choices)
		
		selected_projects = []
		
		if len(choices) == 1:
			with wx.MessageDialog(
					self,
					"Do you want to remove Compound Identification data from experiments in the Project?",
					"Remove Compound Identification Data?",
					style=wx.YES_NO | wx.NO_DEFAULT | wx.CENTRE) as dlg:
				if dlg.ShowModal() == wx.ID_YES:
					selected_projects = choices[:]
		
		elif len(choices) > 1:
			with wx.MultiChoiceDialog(
					self,
					"Select Projects to remove Compound Identification data from:",
					"Remove Compound Identification Data",
					choices
					) as dlg:
				if dlg.ShowModal() == wx.ID_OK:
					selected_projects = [choices[x] for x in dlg.GetSelections()]
		
		# Remove the identification data
		for project_name in selected_projects:
			for tab_idx in range(self.notebook.GetPageCount()):
				if self.notebook.GetPageText(tab_idx) == project_name:
					self.notebook.GetPage(tab_idx).remove_identification_data()
					continue
		
		event.Skip()
	
	def on_menu_remove_consolidate(self, event):
		choices = [label for label in self.project_navigator.project_navigator_data.keys() if label != "__root"]
		print(choices)
		
		selected_projects = []
		
		if len(choices) == 1:
			with wx.MessageDialog(
					self,
					"Do you want to remove Consolidate data from the Project?",
					"Remove Consolidate Data?",
					style=wx.YES_NO | wx.NO_DEFAULT | wx.CENTRE) as dlg:
				if dlg.ShowModal() == wx.ID_YES:
					selected_projects = choices[:]
		
		elif len(choices) > 1:
			with wx.MultiChoiceDialog(
					self,
					"Select Projects to remove Consolidate data from:",
					"Remove Consolidate Data",
					choices
					) as dlg:
				if dlg.ShowModal() == wx.ID_OK:
					selected_projects = [choices[x] for x in dlg.GetSelections()]
		
		# Remove the consolidate data
		for project_name in selected_projects:
			for tab_idx in range(self.notebook.GetPageCount()):
				if self.notebook.GetPageText(tab_idx) == project_name:
					self.notebook.GetPage(tab_idx).remove_consolidate_data()
					continue
		
		event.Skip()
	
	def on_menu_remove_alignment(self, event):
		choices = [label for label in self.project_navigator.project_navigator_data.keys() if label != "__root"]
		print(choices)
		
		selected_projects = []
		
		if len(choices) == 1:
			with wx.MessageDialog(
					self,
					"Do you want to remove Alignment data from the Project?",
					"Remove Alignment Data?",
					style=wx.YES_NO | wx.NO_DEFAULT | wx.CENTRE) as dlg:
				if dlg.ShowModal() == wx.ID_YES:
					selected_projects = choices[:]
		
		elif len(choices) > 1:
			with wx.MultiChoiceDialog(
					self,
					"Select Projects to remove Alignment data from:",
					"Remove Alignment Data",
					choices
					) as dlg:
				if dlg.ShowModal() == wx.ID_OK:
					selected_projects = [choices[x] for x in dlg.GetSelections()]
		
		# Remove the alignment
		for project_name in selected_projects:
			for tab_idx in range(self.notebook.GetPageCount()):
				if self.notebook.GetPageText(tab_idx) == project_name:
					self.notebook.GetPage(tab_idx).remove_alignment_data()
					continue
			
		event.Skip()
		
	@staticmethod
	def on_method_editor(_):
		utils.method_editor()
		
	@staticmethod
	def on_ammo_editor(_):
		utils.ammo_editor()
	
	def start_data_viewer_server(self, debug=False):
		self.flask = Process(target=run_flask, args=(debug,))
		self.flask.start()
	
	def stop_data_viewer_server(self):
		if hasattr(self, "flask"):
			try:
				self.flask.terminate()
				self.flask.join()
			except AttributeError:
				pass
	
	def sigint_handler(self, sig, frame):
		self.Close()
		
# end of class GunShotMatch


def run_flask(debug):
	sys.stderr = sys.stdout
	
	pid_dir = pathlib.Path(user_config_dir("GunShotMatch")) / ".pid"
	if not pid_dir.exists():
		pid_dir.mkdir()

	with PidFile(pidname="DataViewer", piddir=str(pid_dir)) as p:
		app.run(debug=debug)

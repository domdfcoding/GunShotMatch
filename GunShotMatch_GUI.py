#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
#
#  Copyright (c) 2017-2019 Dominic Davis-Foster <dominic@davis-foster.co.uk>
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#  MA 02110-1301, USA.
#
#
# generated by wxGlade 0.9.0 on Thu Feb  7 18:16:22 2019
#

import sys
sys.path.append("..")

import wx
import threading
import time
import re
import os
import configparser as ConfigParser
import webbrowser
import GSMatch0_9_0 as GSMatch
import numpy
import sys, os
import itertools
import operator
import time
import traceback
import types
import csv
import subprocess

from utils import pynist
from utils import notification
from utils.helper import rounders
from ChromatogramDisplay import Display
from pyms.GCMS.IO.JCAMP.Function import JCAMP_reader
from pyms.GCMS.Function import build_intensity_matrix, build_intensity_matrix_i
from pyms.Noise.Window import window_smooth, window_smooth_im
from pyms.Noise.SavitzkyGolay import savitzky_golay, savitzky_golay_im
from pyms.Baseline.TopHat import tophat, tophat_im
from pyms.Utils.IO import dump_object
from pyms.Deconvolution.BillerBiemann.Function import BillerBiemann, rel_threshold, num_ions_threshold
from pyms.Noise.Analysis import window_analyzer
from pyms.Peak.Function import peak_sum_area, peak_pt_bounds
from pyms.GCMS.Class import IonChromatogram
from pyms.Peak.IO import load_peaks
from wx.adv import NotificationMessage
#from import_processing import import_processing


# begin wxGlade: dependencies
# end wxGlade

# begin wxGlade: extracode
import wx.html2
import matplotlib
from matplotlib.figure import Figure
from matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as FigureCanvas
from matplotlib.backends.backend_wxagg import NavigationToolbar2WxAgg as NavigationToolbar
import wx.richtext
# end wxGlade


# The following code (C) 2005 Antoine Pitrou 
# https://sourceforge.net/p/wxglade/mailman/message/6475744/
_art_provider = None


def GetStockBitmap(art_id, art_client=None):

	"""
	Get a stock bitmap from its wx.ART_xxx ID
	"""
	global _art_provider
	if _art_provider is None:
		_art_provider = wx.ArtProvider()
	return _art_provider.GetBitmap(id=art_id,
		client=art_client or wx.ART_OTHER)


def GetStockToolbarBitmap(art_id):
	return GetStockBitmap(art_id, wx.ART_TOOLBAR)

TB = GetStockToolbarBitmap
# End (C) Antoine Pitrou

def relpath(path):
	if os.path.normpath(os.path.abspath(path)).startswith(os.path.normpath(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))):
		return os.path.relpath(os.path.abspath(path))
	else:
		return os.path.abspath(path)


def infer_samples(csvpath):

	import os
	
	inferred_samples = []
	directory_listing = os.listdir(csvpath)
	for filename in directory_listing:
		#if filename.lower().endswith(".csv"):
		if filename.endswith("GC_80.CSV"):
			#print filename[:-9]+'MS_80.CSV'
			if os.path.isfile(os.path.join(csvpath,filename[:-9]+'MS_80.CSV')):
				inferred_samples.append(filename[:-10])

	inferred_samples.sort()
	return(inferred_samples)



class Launcher(wx.Frame):
	def __init__(self, *args, **kwds):
		# begin wxGlade: Launcher.__init__
		kwds["style"] = kwds.get("style", 0) | wx.DEFAULT_FRAME_STYLE
		wx.Frame.__init__(self, *args, **kwds)
		
		# Menu Bar
		self.frame_menubar = wx.MenuBar()
		wxglade_tmp_menu = wx.Menu()
		self.frame_menubar.i_paths = wxglade_tmp_menu.Append(wx.ID_ANY, "Configure Paths", "")
		self.Bind(wx.EVT_MENU, self.on_menu_paths, id=self.frame_menubar.i_paths.GetId())
		self.frame_menubar.i_rescan = wxglade_tmp_menu.Append(wx.ID_ANY, "Rescan Files", "")
		self.Bind(wx.EVT_MENU, self.rescan_files, id=self.frame_menubar.i_rescan.GetId())
		wxglade_tmp_menu.AppendSeparator()
		self.frame_menubar.i_about = wxglade_tmp_menu.Append(wx.ID_ANY, "About", "")
		self.Bind(wx.EVT_MENU, self.on_menu_About, id=self.frame_menubar.i_about.GetId())
		self.frame_menubar.i_credits = wxglade_tmp_menu.Append(wx.ID_ANY, "Credits", "")
		self.Bind(wx.EVT_MENU, self.on_menu_Credits, id=self.frame_menubar.i_credits.GetId())
		self.frame_menubar.i_licence = wxglade_tmp_menu.Append(wx.ID_ANY, "Licence", "")
		self.Bind(wx.EVT_MENU, self.on_menu_Licence, id=self.frame_menubar.i_licence.GetId())
		wxglade_tmp_menu.AppendSeparator()
		self.frame_menubar.i_exit = wxglade_tmp_menu.Append(wx.ID_ANY, "Exit", "")
		self.Bind(wx.EVT_MENU, self.on_menu_Exit, id=self.frame_menubar.i_exit.GetId())
		self.frame_menubar.Append(wxglade_tmp_menu, "Menu")
		wxglade_tmp_menu = wx.Menu()
		self.frame_menubar.i_readme = wxglade_tmp_menu.Append(wx.ID_ANY, "View README", "")
		self.Bind(wx.EVT_MENU, self.on_view_readme, id=self.frame_menubar.i_readme.GetId())
		self.frame_menubar.i_documentation = wxglade_tmp_menu.Append(wx.ID_ANY, "View Documentation", "")
		self.Bind(wx.EVT_MENU, self.on_view_doc, id=self.frame_menubar.i_documentation.GetId())
		self.frame_menubar.Append(wxglade_tmp_menu, "Help")
		self.SetMenuBar(self.frame_menubar)
		# Menu Bar end
		self.statusbar = self.CreateStatusBar(2)
		self.statusbar.SetMinHeight(22)
		self.notebook_1 = wx.Notebook(self, wx.ID_ANY)
		self.Launcher = wx.Panel(self.notebook_1, wx.ID_ANY)
		self.Launcher.Bind(wx.EVT_SET_FOCUS, self.refresh_launcher)
		self.launcher_parent_panel = wx.Panel(self.Launcher, wx.ID_ANY, style=wx.BORDER_SUNKEN)
		self.import_outer_panel = wx.Panel(self.launcher_parent_panel, wx.ID_ANY, style=wx.BORDER_RAISED)
		self.import_inner_panel = wx.Panel(self.import_outer_panel, wx.ID_ANY)
		self.import_raw_button = wx.Button(self.import_inner_panel, wx.ID_ANY, "", style=wx.BU_AUTODRAW)
		self.import_raw_button.Bind(wx.EVT_SET_FOCUS, self.refresh_launcher)
		self.import_info_button = wx.BitmapButton(self.import_inner_panel, wx.ID_ANY, wx.Bitmap("./icons/info_48.png", wx.BITMAP_TYPE_ANY))
		self.new_outer_panel = wx.Panel(self.launcher_parent_panel, wx.ID_ANY, style=wx.BORDER_RAISED)
		self.new_inner_panel = wx.Panel(self.new_outer_panel, wx.ID_ANY)
		self.new_project_button = wx.BitmapButton(self.new_inner_panel, wx.ID_ANY, wx.Bitmap("./icons/new_project.110.bmp", wx.BITMAP_TYPE_ANY), style=wx.BU_AUTODRAW | wx.BU_EXACTFIT)
		self.new_info_button = wx.BitmapButton(self.new_inner_panel, wx.ID_ANY, wx.Bitmap("./icons/info_48.png", wx.BITMAP_TYPE_ANY))
		self.open_outer_panel = wx.Panel(self.launcher_parent_panel, wx.ID_ANY, style=wx.BORDER_RAISED)
		self.open_inner_panel = wx.Panel(self.open_outer_panel, wx.ID_ANY)
		self.open_project_button = wx.BitmapButton(self.open_inner_panel, wx.ID_ANY, wx.Bitmap("./icons/open_project.110.bmp", wx.BITMAP_TYPE_ANY))
		self.open_info_button = wx.BitmapButton(self.open_inner_panel, wx.ID_ANY, wx.Bitmap("./icons/info_48.png", wx.BITMAP_TYPE_ANY))
		self.launcher_right_panel = wx.Panel(self.Launcher, wx.ID_ANY, style=wx.BORDER_SUNKEN)
		self.messages_panel = wx.Panel(self.launcher_right_panel, wx.ID_ANY, style=wx.BORDER_RAISED)
		self.messages = wx.richtext.RichTextCtrl(self.messages_panel, wx.ID_ANY, style=wx.richtext.RE_MULTILINE | wx.richtext.RE_READONLY)
		self.Import = wx.Panel(self.notebook_1, wx.ID_ANY)
		self.import_picker_panel = wx.Panel(self.Import, wx.ID_ANY)
		self.check_list_box_2 = wx.CheckListBox(self.import_picker_panel, wx.ID_ANY, choices=[], style=wx.LB_HSCROLL | wx.LB_MULTIPLE | wx.LB_SORT)
		self.import_settings_panel = wx.Panel(self.Import, wx.ID_ANY)
		self.bb_points_value = wx.TextCtrl(self.import_settings_panel, wx.ID_ANY, "", style=wx.TE_NO_VSCROLL)
		self.bb_scans_value = wx.TextCtrl(self.import_settings_panel, wx.ID_ANY, "", style=wx.TE_NO_VSCROLL)
		self.noise_thresh_value = wx.TextCtrl(self.import_settings_panel, wx.ID_ANY, "", style=wx.TE_NO_VSCROLL)
		self.target_range_min_value = wx.TextCtrl(self.import_settings_panel, wx.ID_ANY, "", style=wx.TE_NO_VSCROLL)
		self.target_range_max_value = wx.TextCtrl(self.import_settings_panel, wx.ID_ANY, "", style=wx.TE_NO_VSCROLL)
		self.base_peak_filter_value = wx.TextCtrl(self.import_settings_panel, wx.ID_ANY, "", style=wx.TE_NO_VSCROLL)
		self.tophat_struct_value = wx.TextCtrl(self.import_settings_panel, wx.ID_ANY, "", style=wx.TE_NO_VSCROLL)
		self.tophat_struct_units = wx.Choice(self.import_settings_panel, wx.ID_ANY, choices=["min", "sec", "ms"])
		self.import_apply_btn = wx.Button(self.import_settings_panel, wx.ID_ANY, "Apply")
		self.reset = wx.Button(self.import_settings_panel, wx.ID_ANY, "Default")
		self.import_btn = wx.Button(self.import_settings_panel, wx.ID_ANY, "Import")
		self.import_log_text_control = wx.TextCtrl(self.import_settings_panel, wx.ID_ANY, "", style=wx.TE_CHARWRAP | wx.TE_MULTILINE | wx.TE_READONLY)
		self.New_Project = wx.Panel(self.notebook_1, wx.ID_ANY)
		self.new_project_picker_panel = wx.Panel(self.New_Project, wx.ID_ANY)
		self.check_list_box_1 = wx.CheckListBox(self.new_project_picker_panel, wx.ID_ANY, choices=[], style=wx.LB_HSCROLL | wx.LB_MULTIPLE | wx.LB_SORT)
		self.new_project_settings_panel = wx.Panel(self.New_Project, wx.ID_ANY)
		self.combine_button = wx.Button(self.new_project_settings_panel, wx.ID_ANY, "Combine")
		self.merge_button = wx.Button(self.new_project_settings_panel, wx.ID_ANY, "Merge")
		self.jigsaw_button = wx.Button(self.new_project_settings_panel, wx.ID_ANY, "Jigsaw")
		self.counter_button = wx.Button(self.new_project_settings_panel, wx.ID_ANY, "Counter")
		self.a1_combine = wx.CheckBox(self.new_project_settings_panel, wx.ID_ANY, "Combine")
		self.a1_merge = wx.CheckBox(self.new_project_settings_panel, wx.ID_ANY, "Merge")
		self.a1_open_lo = wx.RadioButton(self.new_project_settings_panel, wx.ID_ANY, "Open soffice", style=wx.RB_GROUP)
		self.a1_jigsaw = wx.RadioButton(self.new_project_settings_panel, wx.ID_ANY, "Jigsaw")
		self.a1_counter = wx.CheckBox(self.new_project_settings_panel, wx.ID_ANY, "Counter")
		self.a1_run_button = wx.Button(self.new_project_settings_panel, wx.ID_ANY, "Run")
		self.a1_reset_button = wx.Button(self.new_project_settings_panel, wx.ID_ANY, "Reset")
		self.a2_combine = wx.CheckBox(self.new_project_settings_panel, wx.ID_ANY, "Combine")
		self.a2_merge = wx.CheckBox(self.new_project_settings_panel, wx.ID_ANY, "Merge")
		self.a2_open_lo = wx.RadioButton(self.new_project_settings_panel, wx.ID_ANY, "Open soffice", style=wx.RB_GROUP)
		self.a2_jigsaw = wx.RadioButton(self.new_project_settings_panel, wx.ID_ANY, "Jigsaw")
		self.a2_counter = wx.CheckBox(self.new_project_settings_panel, wx.ID_ANY, "Counter")
		self.a2_run_button = wx.Button(self.new_project_settings_panel, wx.ID_ANY, "Run")
		self.a2_reset_button = wx.Button(self.new_project_settings_panel, wx.ID_ANY, "Reset")
		self.a3_combine = wx.CheckBox(self.new_project_settings_panel, wx.ID_ANY, "Combine")
		self.a3_merge = wx.CheckBox(self.new_project_settings_panel, wx.ID_ANY, "Merge")
		self.a3_open_lo = wx.RadioButton(self.new_project_settings_panel, wx.ID_ANY, "Open soffice", style=wx.RB_GROUP)
		self.a3_jigsaw = wx.RadioButton(self.new_project_settings_panel, wx.ID_ANY, "Jigsaw")
		self.a3_counter = wx.CheckBox(self.new_project_settings_panel, wx.ID_ANY, "Counter")
		self.a3_run_button = wx.Button(self.new_project_settings_panel, wx.ID_ANY, "Run")
		self.a3_reset_button = wx.Button(self.new_project_settings_panel, wx.ID_ANY, "Reset")
		self.new_project_log_text_control = wx.TextCtrl(self.new_project_settings_panel, wx.ID_ANY, "", style=wx.TE_CHARWRAP | wx.TE_MULTILINE | wx.TE_READONLY)
		self.Chromatogram = wx.Panel(self.notebook_1, wx.ID_ANY)
		self.chromatogram_toolbar = wx.Panel(self.Chromatogram, wx.ID_ANY, style=wx.BORDER_SUNKEN)
		self.chromatogram_toolbar.SetMaxSize((-1,40))
		self.focus_thief = wx.Button(self.chromatogram_toolbar, wx.ID_ANY, "")
		self.CloseProject = wx.BitmapButton(self.chromatogram_toolbar, wx.ID_ANY, wx.Bitmap("./icons/close_24.png", wx.BITMAP_TYPE_ANY), style=wx.BORDER_NONE | wx.BU_AUTODRAW | wx.BU_EXACTFIT | wx.BU_NOTEXT)
		self.OpenSample = wx.BitmapButton(self.chromatogram_toolbar, wx.ID_ANY, wx.Bitmap("./icons/open_24.png", wx.BITMAP_TYPE_ANY), style=wx.BORDER_NONE | wx.BU_AUTODRAW | wx.BU_EXACTFIT | wx.BU_NOTEXT)
		self.ViewPeakList = wx.BitmapButton(self.chromatogram_toolbar, wx.ID_ANY, wx.Bitmap("./icons/list_view_24.png", wx.BITMAP_TYPE_ANY), style=wx.BORDER_NONE | wx.BU_AUTODRAW | wx.BU_EXACTFIT | wx.BU_NOTEXT)
		self.PreviousSample = wx.BitmapButton(self.chromatogram_toolbar, wx.ID_ANY, wx.Bitmap("./icons/go_back_24.png", wx.BITMAP_TYPE_ANY), style=wx.BORDER_NONE | wx.BU_AUTODRAW | wx.BU_EXACTFIT | wx.BU_NOTEXT)
		self.NextSample = wx.BitmapButton(self.chromatogram_toolbar, wx.ID_ANY, wx.Bitmap("./icons/go_forward_24.png", wx.BITMAP_TYPE_ANY), style=wx.BORDER_NONE | wx.BU_AUTODRAW | wx.BU_EXACTFIT | wx.BU_NOTEXT)
		self.ResetView = wx.BitmapButton(self.chromatogram_toolbar, wx.ID_ANY, wx.Bitmap("./icons/home_24.png", wx.BITMAP_TYPE_ANY), style=wx.BORDER_NONE | wx.BU_AUTODRAW | wx.BU_EXACTFIT | wx.BU_NOTEXT)
		self.PreviousView = wx.BitmapButton(self.chromatogram_toolbar, wx.ID_ANY, wx.Bitmap("./icons/go_up_24.png", wx.BITMAP_TYPE_ANY), style=wx.BORDER_NONE | wx.BU_AUTODRAW | wx.BU_EXACTFIT | wx.BU_NOTEXT)
		self.Zoom_Btn = wx.BitmapButton(self.chromatogram_toolbar, wx.ID_ANY, wx.Bitmap("./icons/zoom_24.png", wx.BITMAP_TYPE_ANY), style=wx.BORDER_NONE | wx.BU_AUTODRAW | wx.BU_EXACTFIT | wx.BU_NOTEXT)
		self.Pan_Btn = wx.BitmapButton(self.chromatogram_toolbar, wx.ID_ANY, wx.Bitmap("./icons/gimp-tool-move.png", wx.BITMAP_TYPE_ANY), style=wx.BORDER_NONE | wx.BU_AUTODRAW | wx.BU_EXACTFIT | wx.BU_NOTEXT)
		self.ViewSpectrum_Btn = wx.BitmapButton(self.chromatogram_toolbar, wx.ID_ANY, wx.Bitmap("./icons/Mass_Spectrum_by_Fredrik_Edfors_from_the_Noun_Project.24.png", wx.BITMAP_TYPE_ANY), style=wx.BORDER_NONE | wx.BU_AUTODRAW | wx.BU_EXACTFIT | wx.BU_NOTEXT)
		self.chromatogram_parent_panel = wx.Panel(self.Chromatogram, wx.ID_ANY, style=wx.BORDER_SUNKEN)
		# create the figure with a single plot and create a canvas with the figure
		figure = self.chromatogram_figure = Figure()
		
		matplotlib.projections.register_projection(My_Axes)
		
		axes = self.chromatogram_axes = figure.add_subplot(111,projection="My_Axes")  # 1x1 grid, first subplot
		self.chromatogram_canvas = FigureCanvas(self.chromatogram_parent_panel, wx.ID_ANY, figure)
		self.Help = wx.Panel(self.notebook_1, wx.ID_ANY)
		self.help_toolbar_panel = wx.Panel(self.Help, wx.ID_ANY, style=wx.BORDER_SUNKEN)
		self.chromatogram_toolbar.SetMaxSize((-1,40))
		self.help_focus_thief = wx.Button(self.help_toolbar_panel, wx.ID_ANY, "")
		self.help_back_btn = wx.BitmapButton(self.help_toolbar_panel, wx.ID_ANY, wx.Bitmap("./icons/go_back_24.png", wx.BITMAP_TYPE_ANY), style=wx.BORDER_NONE | wx.BU_AUTODRAW | wx.BU_EXACTFIT | wx.BU_NOTEXT)
		self.help_forward_btn = wx.BitmapButton(self.help_toolbar_panel, wx.ID_ANY, wx.Bitmap("./icons/go_forward_24.png", wx.BITMAP_TYPE_ANY), style=wx.BORDER_NONE | wx.BU_AUTODRAW | wx.BU_EXACTFIT | wx.BU_NOTEXT)
		self.help_home_btn = wx.BitmapButton(self.help_toolbar_panel, wx.ID_ANY, wx.Bitmap("./icons/home_24.png", wx.BITMAP_TYPE_ANY), style=wx.BORDER_NONE | wx.BU_AUTODRAW | wx.BU_EXACTFIT | wx.BU_NOTEXT)
		self.help_url_text_ctrl = wx.TextCtrl(self.help_toolbar_panel, wx.ID_ANY, "", style=wx.TE_NO_VSCROLL | wx.TE_PROCESS_ENTER)
		self.help_go_btn = wx.BitmapButton(self.help_toolbar_panel, wx.ID_ANY, wx.Bitmap("./icons/go_24.png", wx.BITMAP_TYPE_ANY), style=wx.BORDER_NONE | wx.BU_AUTODRAW | wx.BU_EXACTFIT | wx.BU_NOTEXT)
		self.help_readme_btn = wx.BitmapButton(self.help_toolbar_panel, wx.ID_ANY, wx.Bitmap("./icons/help_24.png", wx.BITMAP_TYPE_ANY), style=wx.BORDER_NONE | wx.BU_AUTODRAW | wx.BU_EXACTFIT | wx.BU_NOTEXT)
		self.help_github_btn = wx.BitmapButton(self.help_toolbar_panel, wx.ID_ANY, wx.Bitmap("./icons/GitHub-Mark_24.png", wx.BITMAP_TYPE_ANY), style=wx.BORDER_NONE | wx.BU_AUTODRAW | wx.BU_EXACTFIT | wx.BU_NOTEXT)
		self.help_open_browser_btn = wx.Button(self.help_toolbar_panel, wx.ID_ANY, "Open in browser")
		self.help_parent_panel = wx.Panel(self.Help, wx.ID_ANY, style=wx.BORDER_SUNKEN)
		self.help_browser = wx.html2.WebView.New(self.help_parent_panel, wx.ID_ANY)
		self.help_home ="http://www.google.co.uk"
		self.help_browser.LoadURL(self.help_home)

		self.__set_properties()
		self.__do_layout()

		self.Bind(wx.EVT_BUTTON, self.on_import, self.import_raw_button)
		self.Bind(wx.EVT_BUTTON, self.do_import_info, self.import_info_button)
		self.Bind(wx.EVT_BUTTON, self.on_new_project, self.new_project_button)
		self.Bind(wx.EVT_BUTTON, self.do_new_info, self.new_info_button)
		self.Bind(wx.EVT_BUTTON, self.on_open_project, self.open_project_button)
		self.Bind(wx.EVT_BUTTON, self.do_open_info, self.open_info_button)
		self.Bind(wx.EVT_BUTTON, self.import_apply, self.import_apply_btn)
		self.Bind(wx.EVT_BUTTON, self.do_reset, self.reset)
		self.Bind(wx.EVT_BUTTON, self.do_import, self.import_btn)
		self.Bind(wx.EVT_BUTTON, self.do_combine, self.combine_button)
		self.Bind(wx.EVT_BUTTON, self.do_merge, self.merge_button)
		self.Bind(wx.EVT_BUTTON, self.do_jigsaw, self.jigsaw_button)
		self.Bind(wx.EVT_BUTTON, self.do_counter, self.counter_button)
		self.Bind(wx.EVT_BUTTON, self.do_auto1_run, self.a1_run_button)
		self.Bind(wx.EVT_BUTTON, self.do_auto1_reset, self.a1_reset_button)
		self.Bind(wx.EVT_BUTTON, self.do_auto2_run, self.a2_run_button)
		self.Bind(wx.EVT_BUTTON, self.do_auto2_reset, self.a2_reset_button)
		self.Bind(wx.EVT_BUTTON, self.do_auto3_run, self.a3_run_button)
		self.Bind(wx.EVT_BUTTON, self.do_auto3_reset, self.a3_reset_button)
		self.Bind(wx.EVT_BUTTON, self.on_close_project, self.CloseProject)
		self.Bind(wx.EVT_BUTTON, self.on_open_sample, self.OpenSample)
		self.Bind(wx.EVT_BUTTON, self.on_view_peak_list, self.ViewPeakList)
		self.Bind(wx.EVT_BUTTON, self.on_previous_sample, self.PreviousSample)
		self.Bind(wx.EVT_BUTTON, self.on_next_sample, self.NextSample)
		self.Bind(wx.EVT_BUTTON, self.on_chromatogram_reset_view, self.ResetView)
		self.Bind(wx.EVT_BUTTON, self.on_chromatogram_previous_view, self.PreviousView)
		self.Bind(wx.EVT_BUTTON, self.on_chromatogram_zoom, self.Zoom_Btn)
		self.Bind(wx.EVT_BUTTON, self.on_chromatogram_pan, self.Pan_Btn)
		self.Bind(wx.EVT_BUTTON, self.on_view_spectrum, self.ViewSpectrum_Btn)
		self.Bind(wx.EVT_BUTTON, self.on_help_back, self.help_back_btn)
		self.Bind(wx.EVT_BUTTON, self.on_help_forward, self.help_forward_btn)
		self.Bind(wx.EVT_BUTTON, self.on_help_home, self.help_home_btn)
		self.Bind(wx.EVT_TEXT_ENTER, self.on_help_go, self.help_url_text_ctrl)
		self.Bind(wx.EVT_BUTTON, self.on_help_go, self.help_go_btn)
		self.Bind(wx.EVT_BUTTON, self.on_help_readme, self.help_readme_btn)
		self.Bind(wx.EVT_BUTTON, self.on_help_github, self.help_github_btn)
		self.Bind(wx.EVT_BUTTON, self.on_help_browser, self.help_open_browser_btn)
		# end wxGlade

		
		
		self.Config = ConfigParser.ConfigParser()
		self.Config.read("config.ini")
	
		self.rescan_files()
		
		# Read import settings
		self.bb_points_value.SetValue(self.Config.get("import", "bb_points"))
		self.bb_scans_value.SetValue(self.Config.get("import", "bb_scans"))
		self.noise_thresh_value.SetValue(self.Config.get("import", "noise_thresh"))
		target_range = self.Config.get("import", "target_range").split(",")
		self.target_range_min_value.SetValue(target_range[0].strip())
		self.target_range_max_value.SetValue(target_range[1].strip())
		self.base_peak_filter_value.SetValue(self.Config.get("import", "exclude_ions"))
		self.tophat_struct_value.SetValue(self.Config.get("import", "tophat"))
		tophat_unit = self.Config.get("import", "tophat_unit")
		if tophat_unit == "m": tophat_unit = 0
		elif tophat_unit == "s": tophat_unit = 1
		elif tophat_unit == "ms": tophat_unit = 2
		self.tophat_struct_units.SetSelection(tophat_unit)
		
		self.check_list_box_1.Clear()
		self.check_list_box_1.AppendItems(self.sample_choices)

		self.check_list_box_2.Clear()
		for item in self.raw_list:
			self.check_list_box_2.Append(item)
		
		self.Bind(wx.EVT_SIZE,self.size_change)
		self.Bind(wx.EVT_MAXIMIZE,self.size_change)
		self.Bind(wx.EVT_CLOSE,self.on_close)
		
	#	self.SetMinSize((783,650))
	#	self.SetSize((783,650))
	
		self.SetMinSize((1140,650))
		self.SetSize((1140,650))
		
		
		self.toolbar = NavigationToolbar(self.chromatogram_canvas)
		self.toolbar.Hide()
		
		self.chrom_zoom = True
		self.chrom_pan = False
		self.chrom_spec = False
		
				
		# Constrain zoom to x axis only
		# From https://stackoverflow.com/questions/16705452/matplotlib-forcing-pan-zoom-to-constrain-to-x-axes
		def press_zoom(self, event):
			event.key='x'
			NavigationToolbar.press_zoom(self,event)
		
		figure.canvas.toolbar.press_zoom=types.MethodType(press_zoom, figure.canvas.toolbar)

		# Load Saved TIC
		jcamp_file = "./lib/UNIQUE2_SUBTRACT.JDX"		
		sample_name = os.path.splitext(os.path.basename(jcamp_file))[0]

		time_list = []
		intensity_list = []
		
		with open("./{}_tic.dat".format(sample_name)) as tic_file:
			ticreader = csv.reader(tic_file,delimiter=" ")
			for row in ticreader:
				row = list(filter(None, row))
				intensity_array = intensity_list.append(float(row[1]))
				time_list.append(float(row[0]))

		intensity_array = numpy.array(intensity_list)
		tic = IonChromatogram(intensity_array,time_list)
		
		peak_list = load_peaks("./{}_peaks.dat".format(sample_name)) 
		
		
		


		display = Display(figure, axes)
		display.plot_tic(tic,"TIC")
		#display.plot_peaks(filtered_peak_list, "Peaks")
		display.do_plotting('TIC and PyMS Detected Peaks')
		
		y = tic.get_intensity_array()
		x = tic.get_time_list()
		
		axes.set_ylim(bottom = 0)
		axes.set_xlim(left=0,right=max(x))
		axes.set_xlabel("Retention Time")
		axes.set_ylabel("Intensity")
		
		figure.subplots_adjust(left = 0.1,bottom=0.125,top=0.9, right=0.97)
		#figure.tight_layout()
		self.chromatogram_canvas.draw()

		#def on_xlims_change(ax):
		def update_ylim(*args):
		#	print(*args)
		#	print(str(*args).startswith("MPL MouseEvent")) # Pan
			if (str(*args).startswith("My_AxesSubplot") and not self.Zoom_Btn.IsEnabled()) or (str(*args).startswith("MPL MouseEvent") and not self.Pan_Btn.IsEnabled()): # Zoom, Pan
			#	print("updated xlims: ", axes.get_xlim())
				min_x_index = (numpy.abs(x - axes.get_xlim()[0])).argmin()
				max_x_index = (numpy.abs(x - axes.get_xlim()[1])).argmin()
			#	print(min_x_index, max_x_index)
				
				y_vals_for_range = numpy.take(y,[idx for idx in range(min_x_index, max_x_index)])
			#	print(max(y_vals_for_range))
				axes.set_ylim(bottom = 0, top=max(y_vals_for_range)*1.1)
				figure.canvas.draw()
			#	print("x-val: {}, y-val:{}
				self.size_change(0)

		self.chromatogram_axes.callbacks.connect('xlim_changed', update_ylim)
		self.chromatogram_figure.canvas.callbacks.connect("button_release_event",update_ylim)
		
		#print(axes.get_ylim())
		
		self.Center()
		self.Bind(EVT_STATUS, self.OnStatus)
		self.Bind(EVT_CONVERSION, self.OnImportDone)
		self.Bind(EVT_CONVERSION_LOG, self.OnImportLog)
		self.Bind(wx.html2.EVT_WEBVIEW_NAVIGATED, self.help_update_url)
		self.status_buffer = []
		self.worker = StatusThread(self, 1)
		#self.worker.daemon = True
		self.worker.start()
		self.SetIcon(wx.Icon("lib/GunShotMatch.ico"))
		
		# Move window to last position	
		internal_config = ConfigParser.ConfigParser()
		internal_config.read("lib/gsmatch.ini")			
		position = internal_config.get("MAIN", "position").split(",")
		position = tuple([int(x) for x in position])
		#print(position)
		self.Move(*position)



	def __set_properties(self):
		# begin wxGlade: Launcher.__set_properties
		self.SetTitle("GunShotMatch")
		_icon = wx.NullIcon
		_icon.CopyFromBitmap(wx.Bitmap("./lib/GunShotMatch logo256.png", wx.BITMAP_TYPE_ANY))
		self.SetIcon(_icon)
		self.statusbar.SetStatusWidths([350, 300])
		
		# statusbar fields
		statusbar_fields = ["Status:", ""]
		for i in range(len(statusbar_fields)):
			self.statusbar.SetStatusText(statusbar_fields[i], i)
		self.import_raw_button.SetMinSize((128, 128))
		self.import_raw_button.SetToolTip("Import .RAW Files")
		self.import_raw_button.SetBitmap(wx.Bitmap("./icons/import.110.bmp", wx.BITMAP_TYPE_ANY))
		self.import_info_button.SetToolTip("Show help for \"Import\"")
		self.import_info_button.SetSize(self.import_info_button.GetBestSize())
		self.new_project_button.SetMinSize((128, 128))
		self.new_project_button.SetToolTip("Create New Project")
		self.new_info_button.SetToolTip("Show help for \"New Project\"")
		self.new_info_button.SetSize(self.new_info_button.GetBestSize())
		self.open_project_button.SetMinSize((128, 128))
		self.open_project_button.SetToolTip("Open Project")
		self.open_info_button.SetToolTip("Show help for \"Open Project\"")
		self.open_info_button.SetSize(self.open_info_button.GetBestSize())
		self.check_list_box_2.SetMinSize((256, 128))
		self.check_list_box_2.SetMinSize((256, 128))
		self.bb_points_value.SetMinSize((50, 29))
		self.bb_points_value.SetMaxLength(4)
		self.bb_scans_value.SetMinSize((50, 29))
		self.bb_scans_value.SetMaxLength(4)
		self.noise_thresh_value.SetMinSize((50, 29))
		self.noise_thresh_value.SetMaxLength(4)
		self.target_range_min_value.SetMinSize((55, 29))
		self.target_range_min_value.SetMaxLength(5)
		self.target_range_max_value.SetMinSize((55, 29))
		self.target_range_max_value.SetMaxLength(5)
		self.base_peak_filter_value.SetMinSize((300, 29))
		self.base_peak_filter_value.SetToolTip("Peaks with these base ions (i.e. the most intense peak in the mass spectrum) will be excluded from the results. This can be useful for excluding compounds related to septum bleed, which usually have a base ion at m/z 73")
		self.tophat_struct_value.SetMinSize((50, 29))
		self.tophat_struct_value.SetMaxLength(4)
		self.tophat_struct_units.SetSelection(0)
		self.check_list_box_1.SetMinSize((256, 128))
		self.combine_button.SetToolTip("Combine GS and MS output into a single file")
		self.merge_button.SetToolTip("Merge the selected samples into one and align the peaks where the retention time mateches exactly")
		self.jigsaw_button.SetToolTip("Align peaks between the selected samples based on retention time and identity")
		self.counter_button.SetToolTip("Find the compounds that appear in every sample and perform final analysis")
		self.a1_combine.SetValue(1)
		self.a1_merge.SetValue(1)
		self.a1_jigsaw.SetValue(1)
		self.a1_counter.SetValue(1)
		self.a1_run_button.SetMinSize((50, -1))
		self.a1_reset_button.SetMinSize((70, -1))
		self.a2_combine.SetValue(1)
		self.a2_merge.SetValue(1)
		self.a2_jigsaw.SetValue(1)
		self.a2_counter.SetValue(1)
		self.a2_run_button.SetMinSize((50, -1))
		self.a2_reset_button.SetMinSize((70, -1))
		self.a3_combine.SetValue(1)
		self.a3_merge.SetValue(1)
		self.a3_jigsaw.SetValue(1)
		self.a3_counter.SetValue(1)
		self.a3_run_button.SetMinSize((50, -1))
		self.a3_reset_button.SetMinSize((70, -1))
		self.focus_thief.SetMinSize((1, 1))
		self.CloseProject.SetMinSize((38, 38))
		self.CloseProject.SetToolTip("Close Project")
		self.OpenSample.SetMinSize((38, 38))
		self.OpenSample.SetToolTip("Open Sample Chromatogram")
		self.ViewPeakList.SetMinSize((38, 38))
		self.ViewPeakList.SetToolTip("View Peak List")
		self.PreviousSample.SetMinSize((38, 38))
		self.PreviousSample.SetToolTip("Previous Sample")
		self.NextSample.SetMinSize((38, 38))
		self.NextSample.SetToolTip("Next Sample")
		self.ResetView.SetMinSize((38, 38))
		self.ResetView.SetToolTip("Reset View")
		self.PreviousView.SetMinSize((38, 38))
		self.PreviousView.SetToolTip("Previous View")
		self.Zoom_Btn.SetMinSize((38, 38))
		self.Zoom_Btn.SetToolTip("Pan")
		self.Pan_Btn.SetMinSize((38, 38))
		self.Pan_Btn.SetToolTip("Pan")
		self.ViewSpectrum_Btn.SetMinSize((38, 38))
		self.ViewSpectrum_Btn.SetToolTip("View Mass Spectrum")
		self.chromatogram_toolbar.SetMinSize((-1, 32))
		self.chromatogram_canvas.SetMinSize((1, 1))
		self.help_focus_thief.SetMinSize((1, 1))
		self.help_back_btn.SetMinSize((38, 38))
		self.help_back_btn.SetToolTip("Go back")
		self.help_forward_btn.SetMinSize((38, 38))
		self.help_forward_btn.SetToolTip("Go forward")
		self.help_home_btn.SetMinSize((38, 38))
		self.help_home_btn.SetToolTip("Open the homepage")
		self.help_url_text_ctrl.SetMinSize((380, -1))
		self.help_go_btn.SetMinSize((38, 38))
		self.help_go_btn.SetToolTip("Go to URL")
		self.help_readme_btn.SetMinSize((38, 38))
		self.help_readme_btn.SetToolTip("View Readme")
		self.help_github_btn.SetMinSize((38, 38))
		self.help_github_btn.SetToolTip("View GitHub page")
		self.help_toolbar_panel.SetMaxSize((10000000,40))
		# end wxGlade

	def __do_layout(self):
		# begin wxGlade: Launcher.__do_layout
		parent_sizer = wx.BoxSizer(wx.VERTICAL)
		help_parent_sizer = wx.BoxSizer(wx.VERTICAL)
		help_main_sizer = wx.BoxSizer(wx.VERTICAL)
		help_toolbar_sizer = wx.BoxSizer(wx.HORIZONTAL)
		chromatogram_parent_sizer = wx.BoxSizer(wx.VERTICAL)
		chromatogram_main_sizer = wx.BoxSizer(wx.VERTICAL)
		chrom_toolbar_sizer = wx.BoxSizer(wx.HORIZONTAL)
		new_project_sizer = wx.BoxSizer(wx.HORIZONTAL)
		new_project_settings_sizer = wx.BoxSizer(wx.VERTICAL)
		autoprocess_sizer = wx.BoxSizer(wx.HORIZONTAL)
		auto_3_sizer = wx.BoxSizer(wx.VERTICAL)
		auto_3_button_sizer = wx.BoxSizer(wx.HORIZONTAL)
		auto_2_sizer = wx.BoxSizer(wx.VERTICAL)
		auto_2_button_sizer = wx.BoxSizer(wx.HORIZONTAL)
		auto_1_sizer = wx.BoxSizer(wx.VERTICAL)
		auto_1_button_sizer = wx.BoxSizer(wx.HORIZONTAL)
		individual_step_sizer = wx.BoxSizer(wx.HORIZONTAL)
		new_project_picker_sizer = wx.BoxSizer(wx.VERTICAL)
		import_tab_sizer = wx.BoxSizer(wx.HORIZONTAL)
		import_settings_v_sizer = wx.BoxSizer(wx.VERTICAL)
		import_settings_h_sizer = wx.BoxSizer(wx.HORIZONTAL)
		import_settings_right_sizer = wx.BoxSizer(wx.VERTICAL)
		import_settings_button_sizer = wx.BoxSizer(wx.HORIZONTAL)
		tophat_grid_sizer = wx.FlexGridSizer(1, 3, 0, 0)
		import_settings_left_sizer = wx.BoxSizer(wx.VERTICAL)
		target_range_grid_sizer = wx.FlexGridSizer(1, 4, 0, 0)
		noise_thresh_grid_sizer = wx.FlexGridSizer(1, 3, 0, 0)
		bb_grid_sizer = wx.GridSizer(2, 2, 0, 0)
		import_picker_sizer = wx.BoxSizer(wx.VERTICAL)
		launcher_parent_sizer = wx.BoxSizer(wx.HORIZONTAL)
		launcher_right_sizer = wx.BoxSizer(wx.VERTICAL)
		messages_sizer = wx.BoxSizer(wx.VERTICAL)
		launcher_main_sizer = wx.BoxSizer(wx.VERTICAL)
		open_outer_sizer = wx.BoxSizer(wx.HORIZONTAL)
		open_project_sizer = wx.BoxSizer(wx.HORIZONTAL)
		new_outer_sizer = wx.BoxSizer(wx.HORIZONTAL)
		new_project_sizer_copy = wx.BoxSizer(wx.HORIZONTAL)
		import_outer_sizer = wx.BoxSizer(wx.HORIZONTAL)
		import_sizer = wx.BoxSizer(wx.HORIZONTAL)
		import_sizer.Add(self.import_raw_button, 0, wx.ALIGN_CENTER_VERTICAL | wx.LEFT | wx.RIGHT, 64)
		import_description_label = wx.StaticText(self.import_inner_panel, wx.ID_ANY, "Import PerkinElmer .RAW files, convert to JCAMP-DX format, and perform pre-processing before extracting spectra and generating reports. ", style=wx.ALIGN_LEFT | wx.ST_NO_AUTORESIZE)
		import_description_label.SetMinSize((256, 85))
		import_sizer.Add(import_description_label, 0, wx.ALIGN_CENTER_VERTICAL | wx.RIGHT, 64)
		import_sizer.Add(self.import_info_button, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		self.import_inner_panel.SetSizer(import_sizer)
		import_outer_sizer.Add(self.import_inner_panel, 1, wx.ALL | wx.EXPAND, 15)
		self.import_outer_panel.SetSizer(import_outer_sizer)
		launcher_main_sizer.Add(self.import_outer_panel, 1, wx.ALL | wx.EXPAND, 5)
		new_project_sizer_copy.Add(self.new_project_button, 0, wx.ALIGN_CENTER_VERTICAL | wx.LEFT | wx.RIGHT, 64)
		new_project_description_label = wx.StaticText(self.new_inner_panel, wx.ID_ANY, "Create a new project for a set of samples, identifying the primary compounds in common. ", style=wx.ALIGN_LEFT | wx.ST_NO_AUTORESIZE)
		new_project_description_label.SetMinSize((256, 55))
		new_project_sizer_copy.Add(new_project_description_label, 0, wx.ALIGN_CENTER_VERTICAL | wx.RIGHT, 64)
		new_project_sizer_copy.Add(self.new_info_button, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		self.new_inner_panel.SetSizer(new_project_sizer_copy)
		new_outer_sizer.Add(self.new_inner_panel, 1, wx.ALL | wx.EXPAND, 15)
		self.new_outer_panel.SetSizer(new_outer_sizer)
		launcher_main_sizer.Add(self.new_outer_panel, 1, wx.ALL | wx.EXPAND, 5)
		open_project_sizer.Add(self.open_project_button, 0, wx.ALIGN_CENTER_VERTICAL | wx.LEFT | wx.RIGHT, 64)
		open_project_description_label = wx.StaticText(self.open_inner_panel, wx.ID_ANY, "Open an existing project for viewing, library searching, or further processing", style=wx.ALIGN_LEFT | wx.ST_NO_AUTORESIZE)
		open_project_description_label.SetMinSize((256, 55))
		open_project_sizer.Add(open_project_description_label, 0, wx.ALIGN_CENTER_VERTICAL | wx.RIGHT, 64)
		open_project_sizer.Add(self.open_info_button, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		self.open_inner_panel.SetSizer(open_project_sizer)
		open_outer_sizer.Add(self.open_inner_panel, 1, wx.ALL | wx.EXPAND, 15)
		self.open_outer_panel.SetSizer(open_outer_sizer)
		launcher_main_sizer.Add(self.open_outer_panel, 1, wx.ALL | wx.EXPAND, 5)
		self.launcher_parent_panel.SetSizer(launcher_main_sizer)
		launcher_parent_sizer.Add(self.launcher_parent_panel, 5, wx.EXPAND, 10)
		messages_label = wx.StaticText(self.messages_panel, wx.ID_ANY, "Messages")
		messages_label.SetFont(wx.Font(16, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_BOLD, 0, ""))
		messages_sizer.Add(messages_label, 0, wx.ALL, 5)
		messages_sizer.Add(self.messages, 1, wx.EXPAND, 0)
		self.messages_panel.SetSizer(messages_sizer)
		launcher_right_sizer.Add(self.messages_panel, 1, wx.ALL | wx.EXPAND, 5)
		self.launcher_right_panel.SetSizer(launcher_right_sizer)
		launcher_parent_sizer.Add(self.launcher_right_panel, 2, wx.EXPAND, 10)
		self.Launcher.SetSizer(launcher_parent_sizer)
		import_picker_label = wx.StaticText(self.import_picker_panel, wx.ID_ANY, ".RAW Files to Import:")
		import_picker_sizer.Add(import_picker_label, 0, wx.BOTTOM, 18)
		import_picker_sizer.Add(self.check_list_box_2, 1, wx.BOTTOM | wx.EXPAND, 7)
		self.import_picker_panel.SetSizer(import_picker_sizer)
		import_tab_sizer.Add(self.import_picker_panel, 3, wx.ALL | wx.EXPAND, 10)
		bb_top_text = wx.StaticText(self.import_settings_panel, wx.ID_ANY, "Settings for Biller and Biemann Peak Detection")
		bb_top_text.SetToolTip("Settings for PyMS implementation of BillerBiemann peak detection")
		import_settings_left_sizer.Add(bb_top_text, 0, 0, 0)
		bb_points_label = wx.StaticText(self.import_settings_panel, wx.ID_ANY, "Number of Points: ")
		bb_points_label.SetToolTip("The window width, in data points, for detecting the local maxima")
		bb_grid_sizer.Add(bb_points_label, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		bb_grid_sizer.Add(self.bb_points_value, 0, 0, 0)
		bb_scans_label = wx.StaticText(self.import_settings_panel, wx.ID_ANY, "Number of Scans: ")
		bb_scans_label.SetToolTip("The number of scans across which neighbouring, apexing, ions are combined and considered as belonging to the same peak")
		bb_grid_sizer.Add(bb_scans_label, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		bb_grid_sizer.Add(self.bb_scans_value, 0, 0, 0)
		import_settings_left_sizer.Add(bb_grid_sizer, 1, wx.ALL | wx.EXPAND, 5)
		static_line_9 = wx.StaticLine(self.import_settings_panel, wx.ID_ANY)
		import_settings_left_sizer.Add(static_line_9, 0, wx.BOTTOM | wx.EXPAND, 5)
		import_settings_left_sizer.Add((20, 5), 0, 0, 0)
		noise_thresh_label = wx.StaticText(self.import_settings_panel, wx.ID_ANY, "Noise Filtering Threshold: ")
		noise_thresh_grid_sizer.Add(noise_thresh_label, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		noise_thresh_grid_sizer.Add(self.noise_thresh_value, 0, 0, 0)
		noise_thresh_ions = wx.StaticText(self.import_settings_panel, wx.ID_ANY, "ions")
		noise_thresh_grid_sizer.Add(noise_thresh_ions, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		import_settings_left_sizer.Add(noise_thresh_grid_sizer, 1, wx.EXPAND, 5)
		static_line_2 = wx.StaticLine(self.import_settings_panel, wx.ID_ANY)
		import_settings_left_sizer.Add(static_line_2, 0, wx.EXPAND, 0)
		import_settings_left_sizer.Add((20, 5), 0, 0, 0)
		target_range_top_text = wx.StaticText(self.import_settings_panel, wx.ID_ANY, "Search for peaks between these times:")
		import_settings_left_sizer.Add(target_range_top_text, 0, 0, 0)
		target_range_grid_sizer.Add(self.target_range_min_value, 0, 0, 0)
		target_mid_text = wx.StaticText(self.import_settings_panel, wx.ID_ANY, "minutes and ")
		target_range_grid_sizer.Add(target_mid_text, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		target_range_grid_sizer.Add(self.target_range_max_value, 0, 0, 0)
		target_post_text = wx.StaticText(self.import_settings_panel, wx.ID_ANY, "minutes")
		target_range_grid_sizer.Add(target_post_text, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		import_settings_left_sizer.Add(target_range_grid_sizer, 1, wx.EXPAND | wx.LEFT | wx.RIGHT | wx.TOP, 5)
		import_settings_h_sizer.Add(import_settings_left_sizer, 1, wx.EXPAND, 0)
		static_line_12 = wx.StaticLine(self.import_settings_panel, wx.ID_ANY, style=wx.LI_VERTICAL)
		import_settings_h_sizer.Add(static_line_12, 0, wx.EXPAND | wx.LEFT | wx.RIGHT, 10)
		base_peak_filter_text = wx.StaticText(self.import_settings_panel, wx.ID_ANY, "Exclude peaks with the following base ion(s):")
		base_peak_filter_text.SetToolTip("Peaks with these base ions (i.e. the most intense peak in the mass spectrum) will be excluded from the results. This can be useful for excluding compounds related to septum bleed, which usually have a base ion at m/z 73")
		import_settings_right_sizer.Add(base_peak_filter_text, 0, 0, 0)
		import_settings_right_sizer.Add(self.base_peak_filter_value, 0, wx.BOTTOM | wx.RIGHT | wx.TOP, 6)
		base_peak_filter_text_2 = wx.StaticText(self.import_settings_panel, wx.ID_ANY, "Seperate multiple values with commas ( , )")
		base_peak_filter_text_2.SetToolTip("Peaks with these base ions (i.e. the most intense peak in the mass spectrum) will be excluded from the results. This can be useful for excluding compounds related to septum bleed, which usually have a base ion at m/z 73")
		import_settings_right_sizer.Add(base_peak_filter_text_2, 0, wx.BOTTOM | wx.LEFT, 10)
		static_line_10 = wx.StaticLine(self.import_settings_panel, wx.ID_ANY)
		import_settings_right_sizer.Add(static_line_10, 0, wx.BOTTOM | wx.EXPAND, 5)
		import_settings_right_sizer.Add((20, 5), 0, 0, 0)
		tophat_struct_label = wx.StaticText(self.import_settings_panel, wx.ID_ANY, "Tophat Structural Element: ")
		tophat_struct_label.SetToolTip("Structural element for PyMS Tophat baseline correction. The structural element needs to be larger than the features one wants to retain in the spectrum after the top-hat transform")
		tophat_grid_sizer.Add(tophat_struct_label, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		tophat_grid_sizer.Add(self.tophat_struct_value, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		tophat_grid_sizer.Add(self.tophat_struct_units, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		import_settings_right_sizer.Add(tophat_grid_sizer, 1, wx.EXPAND, 5)
		static_line_11 = wx.StaticLine(self.import_settings_panel, wx.ID_ANY)
		import_settings_right_sizer.Add(static_line_11, 0, wx.BOTTOM | wx.EXPAND, 20)
		import_settings_button_sizer.Add(self.import_apply_btn, 0, wx.ALIGN_BOTTOM | wx.ALIGN_RIGHT | wx.RIGHT, 9)
		import_settings_button_sizer.Add(self.reset, 0, wx.ALIGN_BOTTOM | wx.ALIGN_RIGHT | wx.RIGHT, 9)
		import_settings_button_sizer.Add(self.import_btn, 0, wx.ALIGN_BOTTOM | wx.ALIGN_RIGHT | wx.RIGHT, 9)
		import_settings_right_sizer.Add(import_settings_button_sizer, 1, wx.ALIGN_RIGHT, 20)
		import_settings_h_sizer.Add(import_settings_right_sizer, 1, wx.EXPAND, 0)
		import_settings_v_sizer.Add(import_settings_h_sizer, 1, wx.EXPAND, 0)
		static_line_3 = wx.StaticLine(self.import_settings_panel, wx.ID_ANY)
		import_settings_v_sizer.Add(static_line_3, 0, wx.EXPAND | wx.TOP, 10)
		import_log_label = wx.StaticText(self.import_settings_panel, wx.ID_ANY, "Log:")
		import_settings_v_sizer.Add(import_log_label, 0, wx.TOP, 5)
		import_settings_v_sizer.Add(self.import_log_text_control, 4, wx.EXPAND | wx.TOP, 5)
		self.import_settings_panel.SetSizer(import_settings_v_sizer)
		import_tab_sizer.Add(self.import_settings_panel, 6, wx.ALL | wx.EXPAND, 10)
		self.Import.SetSizer(import_tab_sizer)
		file_picker_label = wx.StaticText(self.new_project_picker_panel, wx.ID_ANY, "Choose the samples to process:")
		new_project_picker_sizer.Add(file_picker_label, 0, wx.BOTTOM, 18)
		new_project_picker_sizer.Add(self.check_list_box_1, 1, wx.BOTTOM | wx.EXPAND, 7)
		self.new_project_picker_panel.SetSizer(new_project_picker_sizer)
		new_project_sizer.Add(self.new_project_picker_panel, 3, wx.ALL | wx.EXPAND, 10)
		individual_steps_label = wx.StaticText(self.new_project_settings_panel, wx.ID_ANY, "Individual Steps")
		new_project_settings_sizer.Add(individual_steps_label, 0, wx.BOTTOM, 10)
		individual_step_sizer.Add(self.combine_button, 0, 0, 0)
		individual_step_sizer.Add(self.merge_button, 0, 0, 0)
		individual_step_sizer.Add(self.jigsaw_button, 0, 0, 0)
		individual_step_sizer.Add(self.counter_button, 0, 0, 0)
		new_project_settings_sizer.Add(individual_step_sizer, 0, wx.BOTTOM | wx.FIXED_MINSIZE, 10)
		static_line_7 = wx.StaticLine(self.new_project_settings_panel, wx.ID_ANY)
		new_project_settings_sizer.Add(static_line_7, 0, wx.BOTTOM | wx.EXPAND, 5)
		autoprocess_label = wx.StaticText(self.new_project_settings_panel, wx.ID_ANY, "Autoprocess")
		new_project_settings_sizer.Add(autoprocess_label, 0, wx.BOTTOM, 10)
		auto_1_label = wx.StaticText(self.new_project_settings_panel, wx.ID_ANY, "Auto 1")
		auto_1_label.SetFont(wx.Font(11, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_BOLD, 0, "Ubuntu"))
		auto_1_sizer.Add(auto_1_label, 0, 0, 0)
		auto_1_sizer.Add(self.a1_combine, 0, 0, 0)
		auto_1_sizer.Add(self.a1_merge, 0, 0, 0)
		auto_1_sizer.Add(self.a1_open_lo, 0, 0, 0)
		auto_1_sizer.Add(self.a1_jigsaw, 0, 0, 0)
		auto_1_sizer.Add(self.a1_counter, 0, 0, 0)
		auto_1_button_sizer.Add(self.a1_run_button, 0, 0, 0)
		auto_1_button_sizer.Add(self.a1_reset_button, 0, 0, 0)
		auto_1_sizer.Add(auto_1_button_sizer, 1, wx.EXPAND | wx.TOP, 5)
		autoprocess_sizer.Add(auto_1_sizer, 1, wx.EXPAND, 0)
		static_line_4 = wx.StaticLine(self.new_project_settings_panel, wx.ID_ANY, style=wx.LI_VERTICAL)
		autoprocess_sizer.Add(static_line_4, 0, wx.EXPAND, 0)
		auto_2_label = wx.StaticText(self.new_project_settings_panel, wx.ID_ANY, "Auto 2")
		auto_2_label.SetFont(wx.Font(11, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_BOLD, 0, "Ubuntu"))
		auto_2_sizer.Add(auto_2_label, 0, 0, 0)
		auto_2_sizer.Add(self.a2_combine, 0, 0, 0)
		auto_2_sizer.Add(self.a2_merge, 0, 0, 0)
		auto_2_sizer.Add(self.a2_open_lo, 0, 0, 0)
		auto_2_sizer.Add(self.a2_jigsaw, 0, 0, 0)
		auto_2_sizer.Add(self.a2_counter, 0, 0, 0)
		auto_2_button_sizer.Add(self.a2_run_button, 0, 0, 0)
		auto_2_button_sizer.Add(self.a2_reset_button, 0, 0, 0)
		auto_2_sizer.Add(auto_2_button_sizer, 1, wx.EXPAND | wx.TOP, 5)
		autoprocess_sizer.Add(auto_2_sizer, 1, wx.EXPAND, 0)
		static_line_5 = wx.StaticLine(self.new_project_settings_panel, wx.ID_ANY, style=wx.LI_VERTICAL)
		autoprocess_sizer.Add(static_line_5, 0, wx.EXPAND, 0)
		auto_3_label = wx.StaticText(self.new_project_settings_panel, wx.ID_ANY, "Auto 3")
		auto_3_label.SetFont(wx.Font(11, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_BOLD, 0, "Ubuntu"))
		auto_3_sizer.Add(auto_3_label, 0, 0, 0)
		auto_3_sizer.Add(self.a3_combine, 0, 0, 0)
		auto_3_sizer.Add(self.a3_merge, 0, 0, 0)
		auto_3_sizer.Add(self.a3_open_lo, 0, 0, 0)
		auto_3_sizer.Add(self.a3_jigsaw, 0, 0, 0)
		auto_3_sizer.Add(self.a3_counter, 0, 0, 0)
		auto_3_button_sizer.Add(self.a3_run_button, 0, 0, 0)
		auto_3_button_sizer.Add(self.a3_reset_button, 0, 0, 0)
		auto_3_sizer.Add(auto_3_button_sizer, 1, wx.EXPAND | wx.TOP, 5)
		autoprocess_sizer.Add(auto_3_sizer, 1, wx.EXPAND, 0)
		static_line_6 = wx.StaticLine(self.new_project_settings_panel, wx.ID_ANY, style=wx.LI_VERTICAL)
		autoprocess_sizer.Add(static_line_6, 0, wx.EXPAND, 0)
		new_project_settings_sizer.Add(autoprocess_sizer, 0, wx.BOTTOM | wx.EXPAND, 20)
		static_line_8 = wx.StaticLine(self.new_project_settings_panel, wx.ID_ANY)
		new_project_settings_sizer.Add(static_line_8, 0, wx.EXPAND, 0)
		new_project_log_label = wx.StaticText(self.new_project_settings_panel, wx.ID_ANY, "Log:")
		new_project_settings_sizer.Add(new_project_log_label, 0, wx.TOP, 5)
		new_project_settings_sizer.Add(self.new_project_log_text_control, 4, wx.EXPAND | wx.TOP, 5)
		self.new_project_settings_panel.SetSizer(new_project_settings_sizer)
		new_project_sizer.Add(self.new_project_settings_panel, 6, wx.ALL | wx.EXPAND, 10)
		self.New_Project.SetSizer(new_project_sizer)
		chrom_toolbar_sizer.Add(self.focus_thief, 0, 0, 0)
		chrom_toolbar_sizer.Add(self.CloseProject, 0, 0, 0)
		chrom_toolbar_sizer.Add(self.OpenSample, 0, 0, 0)
		chrom_toolbar_spacer_1 = wx.StaticLine(self.chromatogram_toolbar, wx.ID_ANY, style=wx.LI_VERTICAL)
		chrom_toolbar_sizer.Add(chrom_toolbar_spacer_1, 0, wx.EXPAND, 0)
		chrom_toolbar_sizer.Add(self.ViewPeakList, 0, 0, 0)
		chrom_toolbar_sizer.Add(self.PreviousSample, 0, 0, 0)
		chrom_toolbar_sizer.Add(self.NextSample, 0, 0, 0)
		chrom_toolbar_spacer_2 = wx.StaticLine(self.chromatogram_toolbar, wx.ID_ANY, style=wx.LI_VERTICAL)
		chrom_toolbar_sizer.Add(chrom_toolbar_spacer_2, 0, wx.EXPAND, 0)
		chrom_toolbar_sizer.Add(self.ResetView, 0, 0, 0)
		chrom_toolbar_sizer.Add(self.PreviousView, 0, 0, 0)
		chrom_toolbar_sizer.Add(self.Zoom_Btn, 0, 0, 0)
		chrom_toolbar_sizer.Add(self.Pan_Btn, 0, 0, 0)
		chrom_toolbar_sizer.Add(self.ViewSpectrum_Btn, 0, 0, 0)
		chrom_toolbar_sizer.Add((0, 0), 0, 0, 0)
		chrom_toolbar_sizer.Add((0, 0), 0, 0, 0)
		self.chromatogram_toolbar.SetSizer(chrom_toolbar_sizer)
		chromatogram_parent_sizer.Add(self.chromatogram_toolbar, 1, wx.EXPAND, 0)
		chromatogram_main_sizer.Add(self.chromatogram_canvas, 1, wx.EXPAND, 0)
		self.chromatogram_parent_panel.SetSizer(chromatogram_main_sizer)
		chromatogram_parent_sizer.Add(self.chromatogram_parent_panel, 1, wx.EXPAND, 10)
		self.Chromatogram.SetSizer(chromatogram_parent_sizer)
		help_toolbar_sizer.Add(self.help_focus_thief, 0, 0, 0)
		help_toolbar_sizer.Add(self.help_back_btn, 0, 0, 0)
		help_toolbar_sizer.Add(self.help_forward_btn, 0, 0, 0)
		help_toolbar_sizer.Add(self.help_home_btn, 0, 0, 0)
		help_toolbar_spacer_1 = wx.StaticLine(self.help_toolbar_panel, wx.ID_ANY, style=wx.LI_VERTICAL)
		help_toolbar_sizer.Add(help_toolbar_spacer_1, 0, wx.EXPAND, 0)
		help_toolbar_sizer.Add(self.help_url_text_ctrl, 0, wx.ALIGN_CENTER_VERTICAL | wx.LEFT, 5)
		help_toolbar_sizer.Add(self.help_go_btn, 0, 0, 0)
		help_toolbar_spacer_2 = wx.StaticLine(self.help_toolbar_panel, wx.ID_ANY, style=wx.LI_VERTICAL)
		help_toolbar_sizer.Add(help_toolbar_spacer_2, 0, wx.EXPAND, 0)
		help_toolbar_sizer.Add(self.help_readme_btn, 0, 0, 0)
		help_toolbar_sizer.Add(self.help_github_btn, 0, 0, 0)
		help_toolbar_spacer_3 = wx.StaticLine(self.help_toolbar_panel, wx.ID_ANY, style=wx.LI_VERTICAL)
		help_toolbar_sizer.Add(help_toolbar_spacer_3, 0, wx.EXPAND, 0)
		help_toolbar_sizer.Add(self.help_open_browser_btn, 0, wx.ALIGN_CENTER_VERTICAL | wx.LEFT, 5)
		self.help_toolbar_panel.SetSizer(help_toolbar_sizer)
		help_parent_sizer.Add(self.help_toolbar_panel, 1, wx.EXPAND, 0)
		help_main_sizer.Add(self.help_browser, 1, wx.EXPAND, 0)
		self.help_parent_panel.SetSizer(help_main_sizer)
		help_parent_sizer.Add(self.help_parent_panel, 1, wx.EXPAND, 10)
		self.Help.SetSizer(help_parent_sizer)
		self.notebook_1.AddPage(self.Launcher, "Launcher")
		self.notebook_1.AddPage(self.Import, "Import")
		self.notebook_1.AddPage(self.New_Project, "New Project")
		self.notebook_1.AddPage(self.Chromatogram, "Chromatogram")
		self.notebook_1.AddPage(self.Help, "Help")
		parent_sizer.Add(self.notebook_1, 1, wx.ALL | wx.EXPAND, 3)
		self.SetSizer(parent_sizer)
		parent_sizer.Fit(self)
		self.Layout()
		# end wxGlade
		
		# Read the configuration from the file
		self.do_auto1_reset(0)
		self.do_auto2_reset(0)
		self.do_auto3_reset(0)

		# Following code by Ray Pasco (c) 2005
		# http://wxpython-users.1045709.n5.nabble.com/Gauge-in-Statusbar-td2321906.html
		import progbar
		sbarfield = 1                   # put progressbar (gauge) in this statusbar field 
		self.maxcount = 1000              # arbitrary full-scale count 
		self.progbar = progbar.ProgressStatusBar (self, self.statusbar,
			2, sbarfield, self.maxcount)
		# Thanks Ray

	def on_close(self, event): # here
		with open("config.ini","w") as configfile:
			self.Config.write(configfile)

		# Read internal settings	
		internal_config = ConfigParser.ConfigParser()
		internal_config.read("lib/gsmatch.ini")	

		screen_pos = self.GetPosition()

		# Save Internal Settings	
		internal_config.set("MAIN","position","{},{}".format(*screen_pos))
		with open("lib/gsmatch.ini","w") as configfile:
			configfile.write("#GunShotMatch Internal Configuration File.\n#Do not edit this file\n")
		with open("lib/gsmatch.ini","a") as configfile:
			internal_config.write(configfile)


		if event.CanVeto(): 
			if any([conversion_thread_running]): # background worker still running
				wx.MessageBox("A process is still running.\nPlease wait for it to finish.","Please Wait",wx.ICON_ERROR | wx.OK)
				event.Veto()
				return
			
			if wx.MessageBox("Close GunShotMatch?",
							 "Please confirm",
							 wx.ICON_QUESTION | wx.YES_NO) != wx.YES:

				event.Veto()
				return

		print("Waiting for threads to finish...")	
		self.worker.join()
		
			
		self.Destroy()  # you may also do:  event.Skip()
						# since the default event handler does call Destroy(), too



	def size_change(self,event):
		#code to run whenever window resized
		self.chromatogram_canvas.draw()
		self.chromatogram_canvas.Refresh()
		if type(event) == wx._core.SizeEvent:
			event.Skip()


	def refresh_launcher(self, event):
		self.launcher_parent_panel.Layout()
		self.launcher_parent_panel.Update()
		self.launcher_parent_panel.Refresh()

	def OnImportDone(self, event):
		self.status("Import Complete",5)

	def get_auto_settings(self,which=1,*args):
		#return self.Config.get("Auto{}".format(which),"combine")\
		#	, self.Config.get("Auto{}".format(which),"merge")\
		#	, self.Config.get("Auto{}".format(which),"open_lo")\
		#	, self.Config.get("Auto{}".format(which),"jigsaw")\
		#	, self.Config.get("Auto{}".format(which),"counter")
		return filter(None,
			["Combine" if self.Config.get("Auto{}".format(which),"combine") else '',
			"Merge" if self.Config.get("Auto{}".format(which),"merge") else '',
			"Open LO" if self.Config.get("Auto{}".format(which),"open_lo") else '',
			 "Jigsaw" if self.Config.get("Auto{}".format(which),"jigsaw") else '',
			 "Counter" if self.Config.get("Auto{}".format(which),"counter") else ''])

	def status(self, message, timeout = 3):
		for i in range(timeout):
			self.status_buffer.append(message)
		self.OnStatus(0)
		
	def reset_status(self):
		self.statusbar.SetStatusText("Status: Ready", 0)
		
	rest_message = "Ready"
	
	def OnStatus(self, evt):
		if len(self.status_buffer)>0:
			self.statusbar.SetStatusText("Status: {}".format(self.status_buffer.pop(0)), 0)
		else:
			self.statusbar.SetStatusText("Status: {}".format(self.rest_message), 0)
	
	def OnImportLog(self, evt):
		self.import_log_text_control.AppendText(evt.log_text)
		#print(evt.log_text.encode("utf-8"))
			
	def on_exit(self, event):
		self.worker._stop()

	def get_sample_list(self, *args):
		selections_index = self.check_list_box_1.GetSelections() + list(self.check_list_box_1.GetCheckedItems())
		selections_index.sort()
	   
		selected = []
		
		for choice in self.sample_choices:
			if self.sample_choices.index(choice) in selections_index:
				selected.append(choice)
		selected.sort()
		self.sample_list = selected
		return selected		

	

	def on_menu_paths(self, event):  # wxGlade: Launcher.<event_handler>
		paths_dlg = paths_dialog(self)
		paths_dlg.Layout()
		if paths_dlg.ShowModal() == wx.ID_OK:
			self.Config.set("main","winlopath",relpath(paths_dlg.winlopath.GetValue()))
			if sys.platform == "win32":
				self.Config.set("main","libnistpath",relpath(paths_dlg.libnistpath.GetValue()))
				self.Config.set("main","nistpath",relpath(paths_dlg.nistpath.GetValue()))
			else:
				self.Config.set("main","linuxlibnistpath",relpath(paths_dlg.libnistpath.GetValue()))
				self.Config.set("main","linuxnistpath",relpath(paths_dlg.nistpath.GetValue()))
			self.Config.set("main","resultspath",relpath(paths_dlg.resultspath.GetValue()))
			self.Config.set("main","rawpath",relpath(paths_dlg.rawpath.GetValue()))
			self.Config.set("main","csvpath",relpath(paths_dlg.csvpath.GetValue()))
			self.Config.set("main","spectrapath",relpath(paths_dlg.spectrapath.GetValue()))
			self.Config.set("main","xypath",relpath(paths_dlg.xypath.GetValue()))
			self.Config.set("main","msppath",relpath(paths_dlg.msppath.GetValue()))
			self.Config.set("main","imagespath",relpath(paths_dlg.imagespath.GetValue()))
			self.Config.set("main","outputpath",relpath(paths_dlg.outputpath.GetValue()))
			self.Config.set("main","exprdir",relpath(paths_dlg.expr_path.GetValue()))
			
			self.status("Preferences applied",5)
		
		self.rescan_files()
		event.Skip()

	def on_menu_About(self, event):  # wxGlade: Launcher.<event_handler>
		about_dlg = AboutDialog(0, self)
		about_dlg.ShowModal()

	def on_menu_Credits(self, event):  # wxGlade: Launcher.<event_handler>
		about_dlg = AboutDialog(1, self)
		about_dlg.ShowModal()
		event.Skip()

	def on_menu_Licence(self, event):  # wxGlade: Launcher.<event_handler>
		about_dlg = AboutDialog(2, self)
		about_dlg.ShowModal()
		event.Skip()

	def on_menu_Exit(self, event):  # wxGlade: Launcher.<event_handler>
		self.Close()

	def on_view_readme(self, event):  # wxGlade: Launcher.<event_handler>
		self.status("Event handler 'on_view_readme' not implemented!")
		#event.Skip()

	def on_view_doc(self, event):  # wxGlade: Launcher.<event_handler>
		self.status("Event handler 'on_view_doc' not implemented!")
		#event.Skip()

	def on_import(self, event):  # wxGlade: Launcher.<event_handler>
#		#print("Event handler 'on_import' not implemented!")
#		#event.Skip()
#		self.raw_list = []
#		# Ultimate List Control version that doesn't work well
#		#dlg = MyMCD(self, 'Select the .RAW file(s) to import', '.RAW Import', choices = raw_list) 
#		dlg = multi_choice_dialog(self, 'Select the .RAW file(s) to import', '.RAW Import', raw_list)
#		res = dlg.ShowModal()
#		if res == wx.ID_OK:
#			file_list = dlg.GetSelections() # the list of RAW files
#			dlg.Destroy()
#			print(file_list)
#			self.converter = ConversionThread(self, file_list)
#			self.converter.start()
		self.notebook_1.SetSelection(1)

	def on_new_project(self, event):  # wxGlade: Launcher.<event_handler>
#		"csvpath = self.Config.get("main","csvpath")
#		file_dlg = multi_choice_dialog(self, 'Choose samples', 'New Project', choices = infer_samples(csvpath))
#
#		res = file_dlg.ShowModal()
#		if res == wx.ID_OK:
#			file_list = file_dlg.GetSelections()
#			print(file_list)
#			file_dlg.Destroy()
#
#			#prog_dlg = wx.ProgressDialog("Title", "Message", maximum=100, parent=self,
#			#	   style=wx.PD_APP_MODAL|wx.PD_AUTO_HIDE)
#			#prog_dlg.Show()
#			##here
#			self.worker = MainThread(self, file_list)
#			self.worker.start()
#			
#			#self.status("Event handler 'on_new_project' not implemented!")
#			#event.Skip()
		self.notebook_1.SetSelection(2)

	def on_open_project(self, event):  # wxGlade: Launcher.<event_handler>
		self.status("Event handler 'on_open_project' not implemented!")
		#event.Skip()

	def do_reset(self, event):  # wxGlade: Launcher.<event_handler>
		# Reset to default Settings
		Config = ConfigParser.ConfigParser()
		Config.read("lib/default.ini")
		self.bb_points_value.SetValue(Config.get("import", "bb_points"))
		self.bb_scans_value.SetValue(Config.get("import", "bb_scans"))
		self.noise_thresh_value.SetValue(Config.get("import", "noise_thresh"))
		target_range = Config.get("import", "target_range").split(",")
		self.target_range_min_value.SetValue(target_range[0].strip())
		self.target_range_max_value.SetValue(target_range[1].strip())
		self.base_peak_filter_value.SetValue(Config.get("import", "exclude_ions"))
		self.tophat_struct_value.SetValue(Config.get("import", "tophat"))

	def import_apply(self, event):  # wxGlade: Launcher.<event_handler>
		# Save the settings
		bb_points = self.bb_points_value.GetValue()
		bb_scans = self.bb_scans_value.GetValue()
		noise_thresh = self.noise_thresh_value.GetValue()
		target_range = (self.target_range_min_value.GetValue(),self.target_range_max_value.GetValue())
		base_peak_filter = self.base_peak_filter_value.GetValue()
		tophat = self.tophat_struct_value.GetValue()
		tophat_unit = ["m","s","ms"][self.tophat_struct_units.GetSelection()]
		
		self.Config.set("import", "bb_points",bb_points)
		self.Config.set("import", "bb_scans",bb_scans)
		self.Config.set("import", "noise_thresh",noise_thresh)
		self.Config.set("import", "target_range","{},{}".format(*target_range))
		self.Config.set("import", "exclude_ions",base_peak_filter)
		self.Config.set("import", "tophat",tophat)
		self.Config.set("import", "tophat_unit",tophat_unit)
		

	def do_import(self, event):  # wxGlade: Launcher.<event_handler>
		# Check if the thread is already running:
		if conversion_thread_running:
			wx.MessageBox("The conversion process is already running.\nPlease wait for it to finish.","Please Wait",wx.ICON_ERROR | wx.OK)
			return
		
		# Clear log
		self.import_log_text_control.Clear()
		
		
		# Save the settings
		bb_points = self.bb_points_value.GetValue()
		bb_scans = self.bb_scans_value.GetValue()
		noise_thresh = self.noise_thresh_value.GetValue()
		target_range = (self.target_range_min_value.GetValue(),self.target_range_max_value.GetValue())
		base_peak_filter = self.base_peak_filter_value.GetValue()
		tophat = self.tophat_struct_value.GetValue()
		tophat_unit = ["m","s","ms"][self.tophat_struct_units.GetSelection()]
		
		self.Config.set("import", "bb_points",bb_points)
		self.Config.set("import", "bb_scans",bb_scans)
		self.Config.set("import", "noise_thresh",noise_thresh)
		self.Config.set("import", "target_range","{},{}".format(*target_range))
		self.Config.set("import", "exclude_ions",base_peak_filter)
		self.Config.set("import", "tophat",tophat)
		self.Config.set("import", "tophat_unit",tophat_unit)
		
		# Files to import
		file_list = list(set(list(self.check_list_box_2.GetCheckedStrings()) + [self.check_list_box_2.GetString(item) for item in self.check_list_box_2.GetSelections()]))

		file_list.sort()
		
		if len(file_list) == 0:
			self.status("Please choose one or more samples!")
			return
		
		self.import_log_text_control.AppendText("Starting conversion of:\n")
		self.import_log_text_control.AppendText(", ".join(file_list))
		self.import_log_text_control.AppendText("\n")
		
		# Clear Selections
		for index in self.check_list_box_2.GetSelections():
			self.check_list_box_2.Deselect(index)		
		self.check_list_box_2.SetCheckedItems([0])
		self.check_list_box_2.Check(0, False)
		#self.check_list_box_2.Select(0)

		
		self.converter = ConversionThread(self, file_list)
		self.converter.start()

	def do_combine(self, event):  # wxGlade: Launcher.<event_handler>
		# Check if the thread is already running:
		if main_thread_running:
			wx.MessageBox("The GunShotMatch process is already running.\nPlease wait for it to finish.","Please Wait",wx.ICON_ERROR | wx.OK)
			return
		
		# Clear log
		self.new_project_log_text_control.Clear()
		
		self.get_sample_list()

		if len(self.sample_list) == 0:
			self.status("Please choose one or more samples!")
			return
		
		self.new_project_log_text_control.AppendText("Processing: \n")
		self.new_project_log_text_control.AppendText(", ".join(self.sample_list))
		self.new_project_log_text_control.AppendText("\n")
		
		# Clear Selections
		self.clear_new_project_selection()

		
		
		print("Event handler 'do_combine' not implemented!")

	def clear_new_project_selection(self):
		for index in self.check_list_box_1.GetSelections():
			self.check_list_box_1.Deselect(index)		
		self.check_list_box_1.SetCheckedItems([0])
		self.check_list_box_1.Check(0, False)
		self.check_list_box_1.Select(0)

	def do_merge(self, event):  # wxGlade: Launcher.<event_handler>
		# Check if the thread is already running:
		if main_thread_running:
			wx.MessageBox("The GunShotMatch process is already running.\nPlease wait for it to finish.","Please Wait",wx.ICON_ERROR | wx.OK)
			return
		
		# Clear log
		self.new_project_log_text_control.Clear()
		
		self.get_sample_list()

		if len(self.sample_list) < 2:
			self.status("Please choose two or more samples!")
			return
		
		self.new_project_log_text_control.AppendText("Processing: \n")
		self.new_project_log_text_control.AppendText(", ".join(self.sample_list))
		self.new_project_log_text_control.AppendText("\n")
		
		# Clear Selections
		self.clear_new_project_selection()
		
		print("Event handler 'do_merge' not implemented!")

	def do_jigsaw(self, event):  # wxGlade: Launcher.<event_handler>
		# Check if the thread is already running:
		if main_thread_running:
			wx.MessageBox("The GunShotMatch process is already running.\nPlease wait for it to finish.","Please Wait",wx.ICON_ERROR | wx.OK)
			return
		
		# Clear log
		self.new_project_log_text_control.Clear()
		
		self.get_sample_list()

		if len(self.sample_list) < 2:
			self.status("Please choose two or more samples!")
			return
		
		self.new_project_log_text_control.AppendText("Processing: \n")
		self.new_project_log_text_control.AppendText(", ".join(self.sample_list))
		self.new_project_log_text_control.AppendText("\n")
		
		# Clear Selections
		self.clear_new_project_selection()

		print("Event handler 'do_jigsaw' not implemented!")
		
	def do_counter(self, event):  # wxGlade: Launcher.<event_handler>
		# Check if the thread is already running:
		if main_thread_running:
			wx.MessageBox("The GunShotMatch process is already running.\nPlease wait for it to finish.","Please Wait",wx.ICON_ERROR | wx.OK)
			return
		
		# Clear log
		self.new_project_log_text_control.Clear()
		
		self.get_sample_list()

		if len(self.sample_list) < 2:
			self.status("Please choose two or more samples!")
			return
		
		self.new_project_log_text_control.AppendText("Processing: \n")
		self.new_project_log_text_control.AppendText(", ".join(self.sample_list))
		self.new_project_log_text_control.AppendText("\n")
		
		# Clear Selections
		self.clear_new_project_selection()
		print("Event handler 'do_counter' not implemented!")

	def do_auto1_run(self, event):  # wxGlade: Launcher.<event_handler>
		self.Config.set("Auto1","combine",str(bool(self.a1_combine.GetValue())))
		self.Config.set("Auto1","merge",str(bool(self.a1_merge.GetValue())))
		self.Config.set("Auto1","open_lo",str(bool(self.a1_open_lo.GetValue())))
		self.Config.set("Auto1","jigsaw",str(bool(self.a1_jigsaw.GetValue())))
		self.Config.set("Auto1","counter",str(bool(self.a1_counter.GetValue())))
		
		# Check if the thread is already running:
		if main_thread_running:
			wx.MessageBox("The GunShotMatch process is already running.\nPlease wait for it to finish.","Please Wait",wx.ICON_ERROR | wx.OK)
			return
		
		# Clear log
		self.new_project_log_text_control.Clear()
		
		self.get_sample_list()

		
		if len(self.sample_list) < 2:
			self.status("Please choose two or more samples!")
			return
		
		# Autoprocess Settings
		auto_settings = self.get_auto_settings(1)

		self.new_project_log_text_control.AppendText("Processing: \n")
		self.new_project_log_text_control.AppendText(", ".join(self.sample_list))
		self.new_project_log_text_control.AppendText("\nAutoprocess Options: \n")
		self.new_project_log_text_control.AppendText(", ".join(auto_settings))
		self.new_project_log_text_control.AppendText("\n")
		
		# Clear Selections
		self.clear_new_project_selection()

		
		print("Event handler 'do_auto1_run' not implemented!")

	def do_auto1_reset(self, event):  # wxGlade: Launcher.<event_handler>
		Config = ConfigParser.ConfigParser()
		Config.read("config.ini")
		
		self.a1_combine.SetValue(int(Config.getboolean("Auto1","combine")))
		self.a1_merge.SetValue(int(Config.getboolean("Auto1","merge")))
		self.a1_open_lo.SetValue(int(Config.getboolean("Auto1","open_lo")))
		self.a1_jigsaw.SetValue(int(Config.getboolean("Auto1","jigsaw")))
		self.a1_counter.SetValue(int(Config.getboolean("Auto1","counter")))

	def do_auto2_run(self, event):  # wxGlade: Launcher.<event_handler>
		self.Config.set("Auto2","combine",str(bool(self.a2_combine.GetValue())))
		self.Config.set("Auto2","merge",str(bool(self.a2_merge.GetValue())))
		self.Config.set("Auto2","open_lo",str(bool(self.a2_open_lo.GetValue())))
		self.Config.set("Auto2","jigsaw",str(bool(self.a2_jigsaw.GetValue())))
		self.Config.set("Auto2","counter",str(bool(self.a2_counter.GetValue())))
		
		# Check if the thread is already running:
		if main_thread_running:
			wx.MessageBox("The GunShotMatch process is already running.\nPlease wait for it to finish.","Please Wait",wx.ICON_ERROR | wx.OK)
			return
		
		# Clear log
		self.new_project_log_text_control.Clear()
		
		self.get_sample_list()
		if len(self.sample_list) < 2:
			self.status("Please choose two or more samples!")
			return
		
		# Autoprocess Settings
		auto_settings = self.get_auto_settings(2)

		self.new_project_log_text_control.AppendText("Processing: \n")
		self.new_project_log_text_control.AppendText(", ".join(self.sample_list))
		self.new_project_log_text_control.AppendText("\nAutoprocess Options: \n")
		self.new_project_log_text_control.AppendText(", ".join(auto_settings))
		self.new_project_log_text_control.AppendText("\n")
		
		# Clear Selections
		self.clear_new_project_selection()

		print("Event handler 'do_auto2_run' not implemented!")

	def do_auto2_reset(self, event):  # wxGlade: Launcher.<event_handler>
		Config = ConfigParser.ConfigParser()
		Config.read("config.ini")
		
		self.a2_combine.SetValue(int(Config.getboolean("Auto2","combine")))
		self.a2_merge.SetValue(int(Config.getboolean("Auto2","merge")))
		self.a2_open_lo.SetValue(int(Config.getboolean("Auto2","open_lo")))
		self.a2_jigsaw.SetValue(int(Config.getboolean("Auto2","jigsaw")))
		self.a2_counter.SetValue(int(Config.getboolean("Auto2","counter")))

	def do_auto3_run(self, event):  # wxGlade: Launcher.<event_handler>
		self.Config.set("Auto3","combine",str(bool(self.a3_combine.GetValue())))
		self.Config.set("Auto3","merge",str(bool(self.a3_merge.GetValue())))
		self.Config.set("Auto3","open_lo",str(bool(self.a3_open_lo.GetValue())))
		self.Config.set("Auto3","jigsaw",str(bool(self.a3_jigsaw.GetValue())))
		self.Config.set("Auto3","counter",str(bool(self.a3_counter.GetValue())))
		
		# Check if the thread is already running:
		if main_thread_running:
			wx.MessageBox("The GunShotMatch process is already running.\nPlease wait for it to finish.","Please Wait",wx.ICON_ERROR | wx.OK)
			return
		
		# Clear log
		self.new_project_log_text_control.Clear()
		
		self.get_sample_list()
		if len(self.sample_list) < 2:
			self.status("Please choose two or more samples!")
			return
		
		# Autoprocess Settings
		auto_settings = self.get_auto_settings(3)

		self.new_project_log_text_control.AppendText("Processing: \n")
		self.new_project_log_text_control.AppendText(", ".join(self.sample_list))
		self.new_project_log_text_control.AppendText("\nAutoprocess Options: \n")
		self.new_project_log_text_control.AppendText(", ".join(auto_settings))
		self.new_project_log_text_control.AppendText("\n")
		
		# Clear Selections
		self.clear_new_project_selection()

		print("Event handler 'do_auto3_run' not implemented!")

	def do_auto3_reset(self, event):  # wxGlade: Launcher.<event_handler>
		Config = ConfigParser.ConfigParser()
		Config.read("config.ini")
		
		self.a3_combine.SetValue(int(Config.getboolean("Auto3","combine")))
		self.a3_merge.SetValue(int(Config.getboolean("Auto3","merge")))
		self.a3_open_lo.SetValue(int(Config.getboolean("Auto3","open_lo")))
		self.a3_jigsaw.SetValue(int(Config.getboolean("Auto3","jigsaw")))
		self.a3_counter.SetValue(int(Config.getboolean("Auto3","counter")))

	def on_close_project(self, event):  # wxGlade: Launcher.<event_handler>
		print("Event handler 'on_close_project' not implemented!")
		self.focus_thief.SetFocus()
		self.size_change(event)
		event.Skip()

	def on_open_sample(self, event):  # wxGlade: Launcher.<event_handler>
		print("Event handler 'on_open_sample' not implemented!")
		self.focus_thief.SetFocus()
		event.Skip()

	def on_view_peak_list(self, event):  # wxGlade: Launcher.<event_handler>
		print("Event handler 'on_view_peak_list' not implemented!")
		self.focus_thief.SetFocus()
		event.Skip()

	def on_previous_sample(self, event):  # wxGlade: Launcher.<event_handler>
		print("Event handler 'on_previous_sample' not implemented!")
		self.focus_thief.SetFocus()
		event.Skip()

	def on_next_sample(self, event):  # wxGlade: Launcher.<event_handler>
		print("Event handler 'on_next_sample' not implemented!")
		self.focus_thief.SetFocus()
		event.Skip()

	def on_chromatogram_reset_view(self, event):  # wxGlade: Launcher.<event_handler>
		self.chromatogram_canvas.toolbar.home()
		self.focus_thief.SetFocus()
		event.Skip()

	def on_chromatogram_previous_view(self, event):  # wxGlade: Launcher.<event_handler>
		self.chromatogram_canvas.toolbar.back()
		self.focus_thief.SetFocus()
		event.Skip()

	def on_chromatogram_zoom(self, event):  # wxGlade: Launcher.<event_handler>
		self.Pan_Btn.Enable()
		self.ViewSpectrum_Btn.Enable()
		self.chromatogram_canvas.toolbar.zoom()
		self.focus_thief.SetFocus()
		self.Zoom_Btn.Disable()		
		event.Skip()

	def on_chromatogram_pan(self, event):  # wxGlade: Launcher.<event_handler>
		self.Zoom_Btn.Enable()
		self.ViewSpectrum_Btn.Enable()
		self.chromatogram_canvas.toolbar.pan()
		self.focus_thief.SetFocus()
		self.Pan_Btn.Disable()
		event.Skip()

	def on_view_spectrum(self, event):  # wxGlade: Launcher.<event_handler>
		self.Pan_Btn.Enable()
		self.Zoom_Btn.Enable()
		print("Event handler 'on_view_spectrum' not implemented!")
		self.focus_thief.SetFocus()
		self.ViewSpectrum_Btn.Disable()
		event.Skip()

	# Other Toolbar Options
	# Save chromatogram as image: save_figure(self, *args)
	# set_cursor(self, cursor)
		#Set the current cursor to one of the :class:`Cursors` enums values.
 
		#If required by the backend, this method should trigger an update in
		#the backend event loop after the cursor is set, as this method may be
		#called e.g. before a long-running task during which the GUI is not
		#updated.
	#set_history_buttons(self)
		#Enable or disable the back/forward button.
	#forward(self, *args)
		#move forward in the view lim stack.


	def do_import_info(self, event):  # wxGlade: Launcher.<event_handler>
		print("Event handler 'do_import_info' not implemented!")
		event.Skip()
	def do_new_info(self, event):  # wxGlade: Launcher.<event_handler>
		print("Event handler 'do_new_info' not implemented!")
		event.Skip()
	def do_open_info(self, event):  # wxGlade: Launcher.<event_handler>
		print("Event handler 'do_open_info' not implemented!")
		event.Skip()
	def on_help_back(self, event):  # wxGlade: Launcher.<event_handler>
		self.help_browser.GoBack()
		self.help_focus_thief.SetFocus()
		event.Skip()
	def on_help_forward(self, event):  # wxGlade: Launcher.<event_handler>
		self.help_browser.GoForward()
		self.help_focus_thief.SetFocus()
		event.Skip()
	def on_help_home(self, event):  # wxGlade: Launcher.<event_handler>
		self.help_browser.LoadURL(self.help_home)
		self.help_focus_thief.SetFocus()
		event.Skip()
	def on_help_go(self, event):  # wxGlade: Launcher.<event_handler>
		print(self.help_url_text_ctrl.GetValue())
		url = self.help_url_text_ctrl.GetValue()
		if not url.startswith('http'):
			url = "http://"+url
		self.help_browser.LoadURL(url)
		self.help_focus_thief.SetFocus()
		#event.Skip()
	def on_help_readme(self, event):  # wxGlade: Launcher.<event_handler>
		self.help_browser.LoadURL("file://{}".format(os.path.join(os.getcwd(),"README.txt")))
		self.help_focus_thief.SetFocus()
		event.Skip()
	def on_help_github(self, event):  # wxGlade: Launcher.<event_handler>
		self.help_browser.LoadURL("http://github.com/domdfcoding/GunShotMatch")
		self.help_focus_thief.SetFocus()
		event.Skip()
	def on_help_browser(self, event):  # wxGlade: Launcher.<event_handler>
		webbrowser.open(self.help_url_text_ctrl.GetValue(),2)
		#print("Event handler 'on_help_browser' not implemented!")
		self.help_focus_thief.SetFocus()
		event.Skip()
		
	def help_update_url(self, event):
		self.help_url_text_ctrl.SetValue(event.GetURL())

	def rescan_files(self):  # wxGlade: Launcher.<event_handler>
		# List of files in RAW directory
		
		raw_dir = os.path.abspath(self.Config.get("main","rawpath"))
		self.raw_list = []
		for rawfile in os.listdir(raw_dir):
			if os.path.splitext(rawfile)[1].lower()==".raw":
				self.raw_list.append(rawfile)
		self.raw_list.sort()
		
		csvpath = self.Config.get("main","csvpath")		
		self.sample_choices = infer_samples(csvpath)
		self.sample_choices.sort()
# end of class Launcher

class multi_choice_dialog(wx.Dialog):
	def __init__(self, *args, **kwds):
		choices.sort()
		self.choices = choices
		self.message = message
		self.caption = caption
		wx.Dialog.__init__(self, parent, -1, style = wx.DEFAULT_DIALOG_STYLE | wx.RESIZE_BORDER)
		self.SetMinSize((358,460))
		self.multi_choice_panel_1 = wx.Panel(self, wx.ID_ANY)
		self.multi_choice_panel_2 = wx.Panel(self.multi_choice_panel_1, wx.ID_ANY)
		self.check_list_box_1 = wx.CheckListBox(self.multi_choice_panel_2, wx.ID_ANY, choices=[], style=wx.LB_HSCROLL | wx.LB_MULTIPLE | wx.LB_SORT)
		
		self.btns = self.CreateSeparatedButtonSizer(wx.OK | wx.CANCEL)
	
		self.__set_properties()
		self.__do_layout()
		self.check_list_box_1.Clear()
		for item in choices:
			self.check_list_box_1.Append(item)
		
		
		
		return # ignore the wxglade code below
		
		
		# begin wxGlade: multi_choice_dialog.__init__
		kwds["style"] = kwds.get("style", 0) | wx.DEFAULT_DIALOG_STYLE | wx.RESIZE_BORDER
		wx.Dialog.__init__(self, *args, **kwds)
		self.SetMinSize((358,410))
		self.multi_choice_panel_1 = wx.Panel(self, wx.ID_ANY)
		self.multi_choice_panel_2 = wx.Panel(self.multi_choice_panel_1, wx.ID_ANY)
		self.check_list_box_1 = wx.CheckListBox(self.multi_choice_panel_2, wx.ID_ANY, choices=[], style=wx.LB_HSCROLL | wx.LB_MULTIPLE | wx.LB_SORT)

		self.__set_properties()
		self.__do_layout()
		# end wxGlade

	def __set_properties(self):
		# begin wxGlade: multi_choice_dialog.__set_properties
		self.SetTitle("multi_choice_dialog")
		_icon = wx.NullIcon
		_icon.CopyFromBitmap(wx.Bitmap("./lib/GunShotMatch logo256.png", wx.BITMAP_TYPE_ANY))
		self.SetIcon(_icon)
		self.check_list_box_1.SetMinSize((256, 128))
		# end wxGlade
		self.SetTitle(self.caption)

	def __do_layout(self):
		# begin wxGlade: multi_choice_dialog.__do_layout
		multi_choice_sizer_1 = wx.BoxSizer(wx.VERTICAL)
		multi_choice_sizer_2 = wx.BoxSizer(wx.VERTICAL)
		multi_choice_sizer_3 = wx.BoxSizer(wx.VERTICAL)
		multi_choice_label = wx.StaticText(self.multi_choice_panel_2, wx.ID_ANY, "Make a selection")
		multi_choice_sizer_3.Add(multi_choice_label, 0, wx.BOTTOM, 18)
		multi_choice_sizer_3.Add(self.check_list_box_1, 1, wx.BOTTOM | wx.EXPAND, 7)
		self.multi_choice_panel_2.SetSizer(multi_choice_sizer_3)
		multi_choice_sizer_2.Add(self.multi_choice_panel_2, 1, wx.EXPAND | wx.LEFT | wx.RIGHT | wx.TOP, 18)
		self.multi_choice_panel_1.SetSizer(multi_choice_sizer_2)
		multi_choice_sizer_1.Add(self.multi_choice_panel_1, 1, wx.BOTTOM | wx.EXPAND, 8)
		self.SetSizer(multi_choice_sizer_1)
		multi_choice_sizer_1.Fit(self)
		self.Layout()
		# end wxGlade
		multi_choice_sizer_2.Add(self.btns, 0, wx.ALL | wx.EXPAND,5)
		#multi_choice_sizer_2.Add(10,0,0)
		multi_choice_label.SetLabel(self.message)
		multi_choice_sizer_1.Fit(self)
		self.Layout()

	def GetSelections(self):
		selected = list(set(list(self.check_list_box_1.GetCheckedStrings()) + [self.check_list_box_1.GetString(item) for item in self.check_list_box_1.GetSelections()]))
		selected.sort()
		return selected


# end of class multi_choice_dialog

class import_settings_dialog(wx.Dialog):
	def __init__(self, *args, **kwds):
		# begin wxGlade: import_settings_dialog.__init__
		kwds["style"] = kwds.get("style", 0) | wx.DEFAULT_DIALOG_STYLE
		wx.Dialog.__init__(self, *args, **kwds)
		self.panel_2 = wx.Panel(self, wx.ID_ANY)
		self.bb_points_value = wx.TextCtrl(self.panel_2, wx.ID_ANY, "", style=wx.TE_NO_VSCROLL)
		self.bb_scans_value = wx.TextCtrl(self.panel_2, wx.ID_ANY, "", style=wx.TE_NO_VSCROLL)
		self.noise_thresh_value = wx.TextCtrl(self.panel_2, wx.ID_ANY, "", style=wx.TE_NO_VSCROLL)
		self.target_range_min_value = wx.TextCtrl(self.panel_2, wx.ID_ANY, "", style=wx.TE_NO_VSCROLL)
		self.target_range_max_value = wx.TextCtrl(self.panel_2, wx.ID_ANY, "", style=wx.TE_NO_VSCROLL)
		self.reset = wx.Button(self.panel_2, wx.ID_ANY, "Default")

		self.__set_properties()
		self.__do_layout()

		self.Bind(wx.EVT_BUTTON, self.do_reset, self.reset)
		# end wxGlade

	def __set_properties(self):
		# begin wxGlade: import_settings_dialog.__set_properties
		self.SetTitle("Import Settings")
		_icon = wx.NullIcon
		_icon.CopyFromBitmap(wx.Bitmap("./lib/GunShotMatch logo256.png", wx.BITMAP_TYPE_ANY))
		self.SetIcon(_icon)
		self.bb_points_value.SetMinSize((50, 29))
		self.bb_points_value.SetMaxLength(4)
		self.bb_scans_value.SetMinSize((50, 29))
		self.bb_scans_value.SetMaxLength(4)
		self.noise_thresh_value.SetMinSize((50, 29))
		self.noise_thresh_value.SetMaxLength(4)
		self.target_range_min_value.SetMinSize((55, 29))
		self.target_range_min_value.SetMaxLength(5)
		self.target_range_max_value.SetMinSize((55, 29))
		self.target_range_max_value.SetMaxLength(5)
		# end wxGlade

		# Read settings
		self.bb_points_value.SetValue(self.parent.Config.get("import", "bb_points"))
		self.bb_scans_value.SetValue(self.parent.Config.get("import", "bb_scans"))
		self.noise_thresh_value.SetValue(self.parent.Config.get("import", "noise_thresh"))
		target_range = self.parent.Config.get("import", "target_range").split(",")
		self.target_range_min_value.SetValue(target_range[0].strip())
		self.target_range_max_value.SetValue(target_range[1].strip())
		

	def __do_layout(self):
		# begin wxGlade: import_settings_dialog.__do_layout
		sizer_6 = wx.BoxSizer(wx.VERTICAL)
		sizer_4 = wx.BoxSizer(wx.VERTICAL)
		grid_sizer_3 = wx.FlexGridSizer(1, 4, 0, 0)
		grid_sizer_2 = wx.FlexGridSizer(1, 3, 0, 0)
		grid_sizer_1 = wx.GridSizer(2, 2, 0, 0)
		bb_top_text = wx.StaticText(self.panel_2, wx.ID_ANY, "Settings for Biller and Biemann Peak Detection")
		sizer_4.Add(bb_top_text, 0, 0, 0)
		bb_points_label = wx.StaticText(self.panel_2, wx.ID_ANY, "Number of Points: ")
		grid_sizer_1.Add(bb_points_label, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		grid_sizer_1.Add(self.bb_points_value, 0, 0, 0)
		bb_scans_label = wx.StaticText(self.panel_2, wx.ID_ANY, "Number of Scans: ")
		grid_sizer_1.Add(bb_scans_label, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		grid_sizer_1.Add(self.bb_scans_value, 0, 0, 0)
		sizer_4.Add(grid_sizer_1, 1, wx.ALL | wx.EXPAND, 5)
		static_line_1 = wx.StaticLine(self.panel_2, wx.ID_ANY)
		sizer_4.Add(static_line_1, 0, wx.EXPAND, 0)
		sizer_4.Add((20, 5), 0, 0, 0)
		noise_thresh_label = wx.StaticText(self.panel_2, wx.ID_ANY, "Noise Filtering Threshold: ")
		grid_sizer_2.Add(noise_thresh_label, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		grid_sizer_2.Add(self.noise_thresh_value, 0, 0, 0)
		noise_thresh_ions = wx.StaticText(self.panel_2, wx.ID_ANY, "ions")
		grid_sizer_2.Add(noise_thresh_ions, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		sizer_4.Add(grid_sizer_2, 1, wx.EXPAND, 5)
		static_line_2 = wx.StaticLine(self.panel_2, wx.ID_ANY)
		sizer_4.Add(static_line_2, 0, wx.EXPAND, 0)
		sizer_4.Add((20, 5), 0, 0, 0)
		target_range_top_text = wx.StaticText(self.panel_2, wx.ID_ANY, "Search for peaks between these times:")
		sizer_4.Add(target_range_top_text, 0, 0, 0)
		grid_sizer_3.Add(self.target_range_min_value, 0, 0, 0)
		target_mid_text = wx.StaticText(self.panel_2, wx.ID_ANY, "minutes and ")
		grid_sizer_3.Add(target_mid_text, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		grid_sizer_3.Add(self.target_range_max_value, 0, 0, 0)
		target_post_text = wx.StaticText(self.panel_2, wx.ID_ANY, "minutes")
		grid_sizer_3.Add(target_post_text, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		sizer_4.Add(grid_sizer_3, 1, wx.EXPAND | wx.LEFT | wx.RIGHT | wx.TOP, 5)
		sizer_4.Add(self.reset, 0, wx.ALIGN_BOTTOM | wx.ALIGN_RIGHT | wx.RIGHT, 9)
		self.panel_2.SetSizer(sizer_4)
		sizer_6.Add(self.panel_2, 1, wx.ALL | wx.EXPAND, 10)
		self.SetSizer(sizer_6)
		sizer_6.Fit(self)
		self.Layout()
		# end wxGlade
		self.btns = self.CreateSeparatedButtonSizer(wx.OK | wx.CANCEL)
		#self.Bind(wx.EVT_BUTTON, self.OK_Button, id=wx.ID_OK)
		sizer_6.Add(self.btns, 0, wx.ALL | wx.EXPAND, 5)

	def do_reset(self, event):  # wxGlade: import_settings_dialog.<event_handler>
		# Reset to default Settings
		Config = ConfigParser.ConfigParser()
		Config.read("lib/default.ini")
		self.bb_points_value.SetValue(Config.get("import", "bb_points"))
		self.bb_scans_value.SetValue(Config.get("import", "bb_scans"))
		self.noise_thresh_value.SetValue(Config.get("import", "noise_thresh"))
		target_range = Config.get("import", "target_range").split(",")
		self.target_range_min_value.SetValue(target_range[0].strip())
		self.target_range_max_value.SetValue(target_range[1].strip())

# end of class import_settings_dialog

class AboutDialog(wx.Dialog):
	def __init__(self, *args, **kwds):
		# begin wxGlade: AboutDialog.__init__
		kwds["style"] = kwds.get("style", 0) | wx.DEFAULT_DIALOG_STYLE
		wx.Dialog.__init__(self, *args, **kwds)
		self.about_top_panel = wx.Panel(self, wx.ID_ANY)
		self.focus_thief = wx.Button(self.about_top_panel, wx.ID_ANY, "")
		self.about_tabs = wx.Notebook(self, wx.ID_ANY)
		self.about_info = wx.Panel(self.about_tabs, wx.ID_ANY)
		self.SetSize((530, 447))
		self.SetMinSize((530, 447))
		self.info_panel = wx.Panel(self.about_info, wx.ID_ANY)
		self.githib_button = wx.Button(self.info_panel, wx.ID_ANY, "github.com/domdfcoding/GunShotMatch", style=wx.BORDER_NONE)
		self.githib_button.Bind(wx.EVT_SET_FOCUS, self.take_focus)
		self.website_button = wx.Button(self.info_panel, wx.ID_ANY, "http://dominic.davis-foster.co.uk/GSR", style=wx.BORDER_NONE)
		self.about_tabs_pane_3 = wx.Panel(self.about_tabs, wx.ID_ANY)
		self.about_tabs_pane_4 = wx.Panel(self.about_tabs, wx.ID_ANY)
		self.SetSize((530, 447))
		self.SetMinSize((530, 447))
		self.panel_4 = wx.Panel(self.about_tabs_pane_4, wx.ID_ANY)
		self.text_ctrl_1 = wx.TextCtrl(self.panel_4, wx.ID_ANY, "                    GNU GENERAL PUBLIC LICENSE\n                       Version 2, June 1991\n\n Copyright (C) 1989, 1991 Free Software Foundation, Inc.,\n 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The licenses for most software are designed to take away your\nfreedom to share and change it.  By contrast, the GNU General Public\nLicense is intended to guarantee your freedom to share and change free\nsoftware--to make sure the software is free for all its users.  This\nGeneral Public License applies to most of the Free Software\nFoundation's software and to any other program whose authors commit to\nusing it.  (Some other Free Software Foundation software is covered by\nthe GNU Lesser General Public License instead.)  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthis service if you wish), that you receive source code or can get it\nif you want it, that you can change the software or use pieces of it\nin new free programs; and that you know you can do these things.\n\n  To protect your rights, we need to make restrictions that forbid\nanyone to deny you these rights or to ask you to surrender the rights.\nThese restrictions translate to certain responsibilities for you if you\ndistribute copies of the software, or if you modify it.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must give the recipients all the rights that\nyou have.  You must make sure that they, too, receive or can get the\nsource code.  And you must show them these terms so they know their\nrights.\n\n  We protect your rights with two steps: (1) copyright the software, and\n(2) offer you this license which gives you legal permission to copy,\ndistribute and/or modify the software.\n\n  Also, for each author's protection and ours, we want to make certain\nthat everyone understands that there is no warranty for this free\nsoftware.  If the software is modified by someone else and passed on, we\nwant its recipients to know that what they have is not the original, so\nthat any problems introduced by others will not reflect on the original\nauthors' reputations.\n\n  Finally, any free program is threatened constantly by software\npatents.  We wish to avoid the danger that redistributors of a free\nprogram will individually obtain patent licenses, in effect making the\nprogram proprietary.  To prevent this, we have made it clear that any\npatent must be licensed for everyone's free use or not licensed at all.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                    GNU GENERAL PUBLIC LICENSE\n   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n  0. This License applies to any program or other work which contains\na notice placed by the copyright holder saying it may be distributed\nunder the terms of this General Public License.  The \"Program\", below,\nrefers to any such program or work, and a \"work based on the Program\"\nmeans either the Program or any derivative work under copyright law:\nthat is to say, a work containing the Program or a portion of it,\neither verbatim or with modifications and/or translated into another\nlanguage.  (Hereinafter, translation is included without limitation in\nthe term \"modification\".)  Each licensee is addressed as \"you\".\n\nActivities other than copying, distribution and modification are not\ncovered by this License; they are outside its scope.  The act of\nrunning the Program is not restricted, and the output from the Program\nis covered only if its contents constitute a work based on the\nProgram (independent of having been made by running the Program).\nWhether that is true depends on what the Program does.\n\n  1. You may copy and distribute verbatim copies of the Program's\nsource code as you receive it, in any medium, provided that you\nconspicuously and appropriately publish on each copy an appropriate\ncopyright notice and disclaimer of warranty; keep intact all the\nnotices that refer to this License and to the absence of any warranty;\nand give any other recipients of the Program a copy of this License\nalong with the Program.\n\nYou may charge a fee for the physical act of transferring a copy, and\nyou may at your option offer warranty protection in exchange for a fee.\n\n  2. You may modify your copy or copies of the Program or any portion\nof it, thus forming a work based on the Program, and copy and\ndistribute such modifications or work under the terms of Section 1\nabove, provided that you also meet all of these conditions:\n\n    a) You must cause the modified files to carry prominent notices\n    stating that you changed the files and the date of any change.\n\n    b) You must cause any work that you distribute or publish, that in\n    whole or in part contains or is derived from the Program or any\n    part thereof, to be licensed as a whole at no charge to all third\n    parties under the terms of this License.\n\n    c) If the modified program normally reads commands interactively\n    when run, you must cause it, when started running for such\n    interactive use in the most ordinary way, to print or display an\n    announcement including an appropriate copyright notice and a\n    notice that there is no warranty (or else, saying that you provide\n    a warranty) and that users may redistribute the program under\n    these conditions, and telling the user how to view a copy of this\n    License.  (Exception: if the Program itself is interactive but\n    does not normally print such an announcement, your work based on\n    the Program is not required to print an announcement.)\n\nThese requirements apply to the modified work as a whole.  If\nidentifiable sections of that work are not derived from the Program,\nand can be reasonably considered independent and separate works in\nthemselves, then this License, and its terms, do not apply to those\nsections when you distribute them as separate works.  But when you\ndistribute the same sections as part of a whole which is a work based\non the Program, the distribution of the whole must be on the terms of\nthis License, whose permissions for other licensees extend to the\nentire whole, and thus to each and every part regardless of who wrote it.\n\nThus, it is not the intent of this section to claim rights or contest\nyour rights to work written entirely by you; rather, the intent is to\nexercise the right to control the distribution of derivative or\ncollective works based on the Program.\n\nIn addition, mere aggregation of another work not based on the Program\nwith the Program (or with a work based on the Program) on a volume of\na storage or distribution medium does not bring the other work under\nthe scope of this License.\n\n  3. You may copy and distribute the Program (or a work based on it,\nunder Section 2) in object code or executable form under the terms of\nSections 1 and 2 above provided that you also do one of the following:\n\n    a) Accompany it with the complete corresponding machine-readable\n    source code, which must be distributed under the terms of Sections\n    1 and 2 above on a medium customarily used for software interchange; or,\n\n    b) Accompany it with a written offer, valid for at least three\n    years, to give any third party, for a charge no more than your\n    cost of physically performing source distribution, a complete\n    machine-readable copy of the corresponding source code, to be\n    distributed under the terms of Sections 1 and 2 above on a medium\n    customarily used for software interchange; or,\n\n    c) Accompany it with the information you received as to the offer\n    to distribute corresponding source code.  (This alternative is\n    allowed only for noncommercial distribution and only if you\n    received the program in object code or executable form with such\n    an offer, in accord with Subsection b above.)\n\nThe source code for a work means the preferred form of the work for\nmaking modifications to it.  For an executable work, complete source\ncode means all the source code for all modules it contains, plus any\nassociated interface definition files, plus the scripts used to\ncontrol compilation and installation of the executable.  However, as a\nspecial exception, the source code distributed need not include\nanything that is normally distributed (in either source or binary\nform) with the major components (compiler, kernel, and so on) of the\noperating system on which the executable runs, unless that component\nitself accompanies the executable.\n\nIf distribution of executable or object code is made by offering\naccess to copy from a designated place, then offering equivalent\naccess to copy the source code from the same place counts as\ndistribution of the source code, even though third parties are not\ncompelled to copy the source along with the object code.\n\n  4. You may not copy, modify, sublicense, or distribute the Program\nexcept as expressly provided under this License.  Any attempt\notherwise to copy, modify, sublicense or distribute the Program is\nvoid, and will automatically terminate your rights under this License.\nHowever, parties who have received copies, or rights, from you under\nthis License will not have their licenses terminated so long as such\nparties remain in full compliance.\n\n  5. You are not required to accept this License, since you have not\nsigned it.  However, nothing else grants you permission to modify or\ndistribute the Program or its derivative works.  These actions are\nprohibited by law if you do not accept this License.  Therefore, by\nmodifying or distributing the Program (or any work based on the\nProgram), you indicate your acceptance of this License to do so, and\nall its terms and conditions for copying, distributing or modifying\nthe Program or works based on it.\n\n  6. Each time you redistribute the Program (or any work based on the\nProgram), the recipient automatically receives a license from the\noriginal licensor to copy, distribute or modify the Program subject to\nthese terms and conditions.  You may not impose any further\nrestrictions on the recipients' exercise of the rights granted herein.\nYou are not responsible for enforcing compliance by third parties to\nthis License.\n\n  7. If, as a consequence of a court judgment or allegation of patent\ninfringement or for any other reason (not limited to patent issues),\nconditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot\ndistribute so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you\nmay not distribute the Program at all.  For example, if a patent\nlicense would not permit royalty-free redistribution of the Program by\nall those who receive copies directly or indirectly through you, then\nthe only way you could satisfy both it and this License would be to\nrefrain entirely from distribution of the Program.\n\nIf any portion of this section is held invalid or unenforceable under\nany particular circumstance, the balance of the section is intended to\napply and the section as a whole is intended to apply in other\ncircumstances.\n\nIt is not the purpose of this section to induce you to infringe any\npatents or other property right claims or to contest validity of any\nsuch claims; this section has the sole purpose of protecting the\nintegrity of the free software distribution system, which is\nimplemented by public license practices.  Many people have made\ngenerous contributions to the wide range of software distributed\nthrough that system in reliance on consistent application of that\nsystem; it is up to the author/donor to decide if he or she is willing\nto distribute software through any other system and a licensee cannot\nimpose that choice.\n\nThis section is intended to make thoroughly clear what is believed to\nbe a consequence of the rest of this License.\n\n  8. If the distribution and/or use of the Program is restricted in\ncertain countries either by patents or by copyrighted interfaces, the\noriginal copyright holder who places the Program under this License\nmay add an explicit geographical distribution limitation excluding\nthose countries, so that distribution is permitted only in or among\ncountries not thus excluded.  In such case, this License incorporates\nthe limitation as if written in the body of this License.\n\n  9. The Free Software Foundation may publish revised and/or new versions\nof the General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\nEach version is given a distinguishing version number.  If the Program\nspecifies a version number of this License which applies to it and \"any\nlater version\", you have the option of following the terms and conditions\neither of that version or of any later version published by the Free\nSoftware Foundation.  If the Program does not specify a version number of\nthis License, you may choose any version ever published by the Free Software\nFoundation.\n\n  10. If you wish to incorporate parts of the Program into other free\nprograms whose distribution conditions are different, write to the author\nto ask for permission.  For software which is copyrighted by the Free\nSoftware Foundation, write to the Free Software Foundation; we sometimes\nmake exceptions for this.  Our decision will be guided by the two goals\nof preserving the free status of all derivatives of our free software and\nof promoting the sharing and reuse of software generally.\n\n                            NO WARRANTY\n\n  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\nFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN\nOTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES\nPROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED\nOR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS\nTO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE\nPROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,\nREPAIR OR CORRECTION.\n\n  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\nREDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\nINCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING\nOUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED\nTO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\nYOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER\nPROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGES.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nconvey the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year><name of author>\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\nAlso add information on how to contact you by electronic and paper mail.\n\nIf the program is interactive, make it output a short notice like this\nwhen it starts in an interactive mode:\n\n    Gnomovision version 69, Copyright (C) year name of author\n    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, the commands you use may\nbe called something other than `show w' and `show c'; they could even be\nmouse-clicks or menu items--whatever suits your program.\n\nYou should also get your employer (if you work as a programmer) or your\nschool, if any, to sign a \"copyright disclaimer\" for the program, if\nnecessary.  Here is a sample; alter the names:\n\n  Yoyodyne, Inc., hereby disclaims all copyright interest in the program\n  `Gnomovision' (which makes passes at compilers) written by James Hacker.\n\n  <signature of Ty Coon>, 1 April 1989\n  Ty Coon, President of Vice\n\nThis General Public License does not permit incorporating your program into\nproprietary programs.  If your program is a subroutine library, you may\nconsider it more useful to permit linking proprietary applications with the\nlibrary.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.\n", style=wx.HSCROLL | wx.TE_MULTILINE | wx.TE_READONLY)

		self.__set_properties()
		self.__do_layout()

		self.Bind(wx.EVT_BUTTON, self.on_about_github, self.githib_button)
		self.Bind(wx.EVT_BUTTON, self.on_about_website, self.website_button)
		# end wxGlade
		self.SetMaxSize((530, 447))
		self.SetMinSize((530, 447))
		self.SetSize((530, 447))
		if page_idx == 2:
			self.about_tabs.SetSelection(2)

	def __set_properties(self):
		# begin wxGlade: AboutDialog.__set_properties
		self.SetTitle("About GunShotMatch")
		_icon = wx.NullIcon
		_icon.CopyFromBitmap(wx.Bitmap("./lib/GunShotMatch logo256.png", wx.BITMAP_TYPE_ANY))
		self.SetIcon(_icon)
		self.focus_thief.SetMinSize((1, 1))
		self.text_ctrl_1.SetMinSize((500, 400))
		# end wxGlade
		self.about_top_panel.SetMinSize((530, 52))
		self.about_top_panel.SetMaxSize((530, 52))
		self.about_top_panel.SetSize((530, 52))
		self.about_tabs_pane_4.SetMinSize((500, 200))
		self.about_tabs_pane_4.SetMaxSize((500, 200))
		self.about_tabs_pane_4.SetSize((500, 200))
		#self.text_ctrl_2.SetBackgroundColour(self.panel_3.GetBackgroundColour())

	def __do_layout(self):
		# begin wxGlade: AboutDialog.__do_layout
		about_parent_sizer = wx.BoxSizer(wx.VERTICAL)
		sizer_9 = wx.BoxSizer(wx.VERTICAL)
		sizer_10 = wx.BoxSizer(wx.VERTICAL)
		info_parent_sizer = wx.BoxSizer(wx.VERTICAL)
		info_sizer = wx.BoxSizer(wx.VERTICAL)
		about_top_sizer = wx.FlexGridSizer(1, 3, 0, 0)
		logo = wx.StaticBitmap(self.about_top_panel, wx.ID_ANY, wx.Bitmap("/home/domdf/ownCloud/GSR/GunShotMatch/GSMatch/lib/GunShotMatch logo48.png", wx.BITMAP_TYPE_ANY))
		about_top_sizer.Add(logo, 0, wx.ALIGN_CENTER_VERTICAL | wx.ALL, 5)
		program_name_label = wx.StaticText(self.about_top_panel, wx.ID_ANY, "GunShotMatch")
		program_name_label.SetFont(wx.Font(14, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_BOLD, 0, "Ubuntu"))
		about_top_sizer.Add(program_name_label, 0, wx.ALIGN_CENTER_VERTICAL | wx.LEFT, 10)
		about_top_sizer.Add(self.focus_thief, 0, 0, 0)
		self.about_top_panel.SetSizer(about_top_sizer)
		about_parent_sizer.Add(self.about_top_panel, 1, 0, 0)
		tagline_label = wx.StaticText(self.info_panel, wx.ID_ANY, "Organic GunShot Residue Analysis", style=wx.ALIGN_CENTER)
		tagline_label.SetFont(wx.Font(14, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_BOLD, 0, "Ubuntu"))
		info_sizer.Add(tagline_label, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.ALL, 15)
		version_label = wx.StaticText(self.info_panel, wx.ID_ANY, "Version <version string goes here>", style=wx.ALIGN_CENTER)
		info_sizer.Add(version_label, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.ALL, 10)
		info_sizer.Add(self.githib_button, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.LEFT | wx.RIGHT | wx.TOP, 10)
		info_sizer.Add(self.website_button, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.BOTTOM | wx.LEFT | wx.RIGHT, 10)
		copyright_label = wx.StaticText(self.info_panel, wx.ID_ANY, "Copyright (c) 2017-2019\nDominic Davis-Foster\nAll rights reserved.", style=wx.ALIGN_CENTER)
		info_sizer.Add(copyright_label, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.ALL, 20)
		self.info_panel.SetSizer(info_sizer)
		info_parent_sizer.Add(self.info_panel, 1, wx.ALL | wx.EXPAND | wx.FIXED_MINSIZE, 5)
		self.about_info.SetSizer(info_parent_sizer)
		sizer_10.Add(self.text_ctrl_1, 0, wx.ALIGN_CENTER | wx.EXPAND, 0)
		self.panel_4.SetSizer(sizer_10)
		sizer_9.Add(self.panel_4, 1, wx.ALL | wx.EXPAND | wx.FIXED_MINSIZE, 5)
		self.about_tabs_pane_4.SetSizer(sizer_9)
		self.about_tabs.AddPage(self.about_info, "Info")
		self.about_tabs.AddPage(self.about_tabs_pane_3, "Credits")
		self.about_tabs.AddPage(self.about_tabs_pane_4, "Licence")
		about_parent_sizer.Add(self.about_tabs, 1, wx.ALL | wx.EXPAND, 3)
		self.SetSizer(about_parent_sizer)
		about_parent_sizer.Fit(self)
		self.Layout()
		# end wxGlade
		self.btns = self.CreateSeparatedButtonSizer(wx.CLOSE)
		about_parent_sizer.Add(self.btns, 0, wx.ALL | wx.EXPAND, 5)
		self.SetSizer(about_parent_sizer)
		about_parent_sizer.Fit(self)
		self.SetMaxSize((530, 447))
		self.SetMinSize((530, 447))
		self.SetSize((530, 447))

	def on_about_github(self, event):  # wxGlade: AboutDialog.<event_handler>
		webbrowser.open("http://github.com/domdfcoding/GunShotMatch",2)
		self.focus_thief.SetFocus()
		event.Skip()

	def on_about_website(self, event):  # wxGlade: AboutDialog.<event_handler>
		webbrowser.open("http://dominic.davis-foster.co.uk/GSR",2)
		self.focus_thief.SetFocus()
		event.Skip()
		
	def take_focus(self, event):
		self.focus_thief.SetFocus()
		event.Skip()

# end of class AboutDialog

class paths_dialog(wx.Dialog):
	def __init__(self, *args, **kwds):
		# begin wxGlade: paths_dialog.__init__
		kwds["style"] = kwds.get("style", 0) | wx.DEFAULT_DIALOG_STYLE | wx.RESIZE_BORDER
		wx.Dialog.__init__(self, *args, **kwds)
		self.SetSize((849, 437))
		self.prefs_panel = wx.Panel(self, wx.ID_ANY)
		self.paths_panel = wx.Panel(self.prefs_panel, wx.ID_ANY)
		self.winlopath = wx.TextCtrl(self.paths_panel, wx.ID_ANY, "", style=wx.TE_NO_VSCROLL)
		self.winlo_clear = wx.BitmapButton(self.paths_panel, wx.ID_ANY, wx.ArtProvider.GetBitmap(wx.ART_GO_BACK, wx.ART_MENU))
		self.winlo_browse = wx.BitmapButton(self.paths_panel, wx.ID_ANY, wx.ArtProvider.GetBitmap(wx.ART_FOLDER_OPEN, wx.ART_MENU))
		self.winlo_help = wx.BitmapButton(self.paths_panel, wx.ID_ANY, wx.ArtProvider.GetBitmap(wx.ART_INFORMATION, wx.ART_MENU))
		self.libnistpath = wx.TextCtrl(self.paths_panel, wx.ID_ANY, "", style=wx.TE_NO_VSCROLL)
		self.libnist_winlo_clear = wx.BitmapButton(self.paths_panel, wx.ID_ANY, wx.ArtProvider.GetBitmap(wx.ART_GO_BACK, wx.ART_MENU))
		self.libnist_browse = wx.BitmapButton(self.paths_panel, wx.ID_ANY, wx.ArtProvider.GetBitmap(wx.ART_FOLDER_OPEN, wx.ART_MENU))
		self.libnist_help = wx.BitmapButton(self.paths_panel, wx.ID_ANY, wx.ArtProvider.GetBitmap(wx.ART_INFORMATION, wx.ART_MENU))
		self.nistpath = wx.TextCtrl(self.paths_panel, wx.ID_ANY, "", style=wx.TE_NO_VSCROLL)
		self.nistpath_clear = wx.BitmapButton(self.paths_panel, wx.ID_ANY, wx.ArtProvider.GetBitmap(wx.ART_GO_BACK, wx.ART_MENU))
		self.nistpath_browse = wx.BitmapButton(self.paths_panel, wx.ID_ANY, wx.ArtProvider.GetBitmap(wx.ART_FOLDER_OPEN, wx.ART_MENU))
		self.nistpath_help = wx.BitmapButton(self.paths_panel, wx.ID_ANY, wx.ArtProvider.GetBitmap(wx.ART_INFORMATION, wx.ART_MENU))
		self.resultspath = wx.TextCtrl(self.paths_panel, wx.ID_ANY, "", style=wx.TE_NO_VSCROLL)
		self.resultspath_clear = wx.BitmapButton(self.paths_panel, wx.ID_ANY, wx.ArtProvider.GetBitmap(wx.ART_GO_BACK, wx.ART_MENU))
		self.resultspath_browse = wx.BitmapButton(self.paths_panel, wx.ID_ANY, wx.ArtProvider.GetBitmap(wx.ART_FOLDER_OPEN, wx.ART_MENU))
		self.rawpath = wx.TextCtrl(self.paths_panel, wx.ID_ANY, "", style=wx.TE_NO_VSCROLL)
		self.rawpath_clear = wx.BitmapButton(self.paths_panel, wx.ID_ANY, wx.ArtProvider.GetBitmap(wx.ART_GO_BACK, wx.ART_MENU))
		self.rawpath_browse = wx.BitmapButton(self.paths_panel, wx.ID_ANY, wx.ArtProvider.GetBitmap(wx.ART_FOLDER_OPEN, wx.ART_MENU))
		self.csvpath = wx.TextCtrl(self.paths_panel, wx.ID_ANY, "", style=wx.TE_NO_VSCROLL)
		self.csvpath_clear = wx.BitmapButton(self.paths_panel, wx.ID_ANY, wx.ArtProvider.GetBitmap(wx.ART_GO_BACK, wx.ART_MENU))
		self.csvpath_browse = wx.BitmapButton(self.paths_panel, wx.ID_ANY, wx.ArtProvider.GetBitmap(wx.ART_FOLDER_OPEN, wx.ART_MENU))
		self.spectrapath = wx.TextCtrl(self.paths_panel, wx.ID_ANY, "", style=wx.TE_NO_VSCROLL)
		self.spectrapath_clear = wx.BitmapButton(self.paths_panel, wx.ID_ANY, wx.ArtProvider.GetBitmap(wx.ART_GO_BACK, wx.ART_MENU))
		self.spectrapath_browse = wx.BitmapButton(self.paths_panel, wx.ID_ANY, wx.ArtProvider.GetBitmap(wx.ART_FOLDER_OPEN, wx.ART_MENU))
		self.xypath = wx.TextCtrl(self.paths_panel, wx.ID_ANY, "", style=wx.TE_NO_VSCROLL)
		self.xypath_clear = wx.BitmapButton(self.paths_panel, wx.ID_ANY, wx.ArtProvider.GetBitmap(wx.ART_GO_BACK, wx.ART_MENU))
		self.xypath_browse = wx.BitmapButton(self.paths_panel, wx.ID_ANY, wx.ArtProvider.GetBitmap(wx.ART_FOLDER_OPEN, wx.ART_MENU))
		self.msppath = wx.TextCtrl(self.paths_panel, wx.ID_ANY, "", style=wx.TE_NO_VSCROLL)
		self.msppath_clear = wx.BitmapButton(self.paths_panel, wx.ID_ANY, wx.ArtProvider.GetBitmap(wx.ART_GO_BACK, wx.ART_MENU))
		self.msppath_browse = wx.BitmapButton(self.paths_panel, wx.ID_ANY, wx.ArtProvider.GetBitmap(wx.ART_FOLDER_OPEN, wx.ART_MENU))
		self.expr_path = wx.TextCtrl(self.paths_panel, wx.ID_ANY, "", style=wx.TE_NO_VSCROLL)
		self.expr_clear = wx.BitmapButton(self.paths_panel, wx.ID_ANY, wx.ArtProvider.GetBitmap(wx.ART_GO_BACK, wx.ART_MENU))
		self.expr_browse = wx.BitmapButton(self.paths_panel, wx.ID_ANY, wx.ArtProvider.GetBitmap(wx.ART_FOLDER_OPEN, wx.ART_MENU))
		self.imagespath = wx.TextCtrl(self.paths_panel, wx.ID_ANY, "", style=wx.TE_NO_VSCROLL)
		self.imagespath_clear = wx.BitmapButton(self.paths_panel, wx.ID_ANY, wx.ArtProvider.GetBitmap(wx.ART_GO_BACK, wx.ART_MENU))
		self.imagespath_browse = wx.BitmapButton(self.paths_panel, wx.ID_ANY, wx.ArtProvider.GetBitmap(wx.ART_FOLDER_OPEN, wx.ART_MENU))
		self.outputpath = wx.TextCtrl(self.paths_panel, wx.ID_ANY, "", style=wx.TE_NO_VSCROLL)
		self.outputpath_clear = wx.BitmapButton(self.paths_panel, wx.ID_ANY, wx.ArtProvider.GetBitmap(wx.ART_GO_BACK, wx.ART_MENU))
		self.outputpath_browse = wx.BitmapButton(self.paths_panel, wx.ID_ANY, wx.ArtProvider.GetBitmap(wx.ART_FOLDER_OPEN, wx.ART_MENU))
		self.reset_button_panel = wx.Panel(self.prefs_panel, wx.ID_ANY)
		self.paths_reset = wx.Button(self.reset_button_panel, wx.ID_ANY, "Reset")

		self.__set_properties()
		self.__do_layout()

		self.Bind(wx.EVT_BUTTON, self.on_winlo_clear, self.winlo_clear)
		self.Bind(wx.EVT_BUTTON, self.on_winlo_browse, self.winlo_browse)
		self.Bind(wx.EVT_BUTTON, self.on_winlo_help, self.winlo_help)
		self.Bind(wx.EVT_BUTTON, self.on_libnist_clear, self.libnist_winlo_clear)
		self.Bind(wx.EVT_BUTTON, self.on_libnist_browse, self.libnist_browse)
		self.Bind(wx.EVT_BUTTON, self.on_libnist_help, self.libnist_help)
		self.Bind(wx.EVT_BUTTON, self.on_nistpath_clear, self.nistpath_clear)
		self.Bind(wx.EVT_BUTTON, self.on_nistpath_browse, self.nistpath_browse)
		self.Bind(wx.EVT_BUTTON, self.on_nistpath_help, self.nistpath_help)
		self.Bind(wx.EVT_BUTTON, self.on_resultspath_clear, self.resultspath_clear)
		self.Bind(wx.EVT_BUTTON, self.on_resultspath_browse, self.resultspath_browse)
		self.Bind(wx.EVT_BUTTON, self.on_rawpath_clear, self.rawpath_clear)
		self.Bind(wx.EVT_BUTTON, self.on_rawpath_browse, self.rawpath_browse)
		self.Bind(wx.EVT_BUTTON, self.on_csvpath_clear, self.csvpath_clear)
		self.Bind(wx.EVT_BUTTON, self.on_csvpath_browse, self.csvpath_browse)
		self.Bind(wx.EVT_BUTTON, self.on_spectrapath_clear, self.spectrapath_clear)
		self.Bind(wx.EVT_BUTTON, self.on_spectrapath_browse, self.spectrapath_browse)
		self.Bind(wx.EVT_BUTTON, self.on_xypath_clear, self.xypath_clear)
		self.Bind(wx.EVT_BUTTON, self.on_xypath_browse, self.xypath_browse)
		self.Bind(wx.EVT_BUTTON, self.on_msppath_clear, self.msppath_clear)
		self.Bind(wx.EVT_BUTTON, self.on_msppath_browse, self.msppath_browse)
		self.Bind(wx.EVT_BUTTON, self.on_expr_path_clear, self.expr_clear)
		self.Bind(wx.EVT_BUTTON, self.on_expr_path_browse, self.expr_browse)
		self.Bind(wx.EVT_BUTTON, self.on_imagespath_clear, self.imagespath_clear)
		self.Bind(wx.EVT_BUTTON, self.on_imagespath_browse, self.imagespath_browse)
		self.Bind(wx.EVT_BUTTON, self.on_outputpath_clear, self.outputpath_clear)
		self.Bind(wx.EVT_BUTTON, self.on_outputpath_browse, self.outputpath_browse)
		self.Bind(wx.EVT_BUTTON, self.do_path_reset, self.paths_reset)
		# end wxGlade

		# Read the configuration from the file
		self.do_path_reset(0)

	def __set_properties(self):
		# begin wxGlade: paths_dialog.__set_properties
		self.SetTitle("Configure Paths")
		_icon = wx.NullIcon
		_icon.CopyFromBitmap(wx.Bitmap("./lib/GunShotMatch logo256.png", wx.BITMAP_TYPE_ANY))
		self.SetIcon(_icon)
		self.SetSize((849, 437))
		self.winlopath.SetMinSize((512, 29))
		self.winlo_clear.SetSize(self.winlo_clear.GetBestSize())
		self.winlo_browse.SetSize(self.winlo_browse.GetBestSize())
		self.winlo_help.SetSize(self.winlo_help.GetBestSize())
		self.libnistpath.SetMinSize((512, 29))
		self.libnist_winlo_clear.SetSize(self.libnist_winlo_clear.GetBestSize())
		self.libnist_browse.SetSize(self.libnist_browse.GetBestSize())
		self.libnist_help.SetSize(self.libnist_help.GetBestSize())
		self.nistpath.SetMinSize((512, 29))
		self.nistpath_clear.SetSize(self.nistpath_clear.GetBestSize())
		self.nistpath_browse.SetSize(self.nistpath_browse.GetBestSize())
		self.nistpath_help.SetSize(self.nistpath_help.GetBestSize())
		self.resultspath.SetMinSize((512, 29))
		self.resultspath_clear.SetSize(self.resultspath_clear.GetBestSize())
		self.resultspath_browse.SetSize(self.resultspath_browse.GetBestSize())
		self.rawpath.SetMinSize((512, 29))
		self.rawpath_clear.SetSize(self.rawpath_clear.GetBestSize())
		self.rawpath_browse.SetSize(self.rawpath_browse.GetBestSize())
		self.csvpath.SetMinSize((512, 29))
		self.csvpath_clear.SetSize(self.csvpath_clear.GetBestSize())
		self.csvpath_browse.SetSize(self.csvpath_browse.GetBestSize())
		self.spectrapath.SetMinSize((512, 29))
		self.spectrapath_clear.SetSize(self.spectrapath_clear.GetBestSize())
		self.spectrapath_browse.SetSize(self.spectrapath_browse.GetBestSize())
		self.xypath.SetMinSize((512, 29))
		self.xypath_clear.SetSize(self.xypath_clear.GetBestSize())
		self.xypath_browse.SetSize(self.xypath_browse.GetBestSize())
		self.msppath.SetMinSize((512, 29))
		self.msppath_clear.SetSize(self.msppath_clear.GetBestSize())
		self.msppath_browse.SetSize(self.msppath_browse.GetBestSize())
		self.expr_path.SetMinSize((512, 29))
		self.expr_clear.SetSize(self.expr_clear.GetBestSize())
		self.expr_browse.SetSize(self.expr_browse.GetBestSize())
		self.imagespath.SetMinSize((512, 29))
		self.imagespath_clear.SetSize(self.imagespath_clear.GetBestSize())
		self.imagespath_browse.SetSize(self.imagespath_browse.GetBestSize())
		self.outputpath.SetMinSize((512, 29))
		self.outputpath_clear.SetSize(self.outputpath_clear.GetBestSize())
		self.outputpath_browse.SetSize(self.outputpath_browse.GetBestSize())
		# end wxGlade

	def __do_layout(self):
		# begin wxGlade: paths_dialog.__do_layout
		prefs_parent_sizer = wx.BoxSizer(wx.VERTICAL)
		paths_parent_sizer = wx.BoxSizer(wx.VERTICAL)
		sizer_1 = wx.BoxSizer(wx.VERTICAL)
		paths_sizer = wx.FlexGridSizer(13, 5, 0, 0)
		winlopath_label = wx.StaticText(self.paths_panel, wx.ID_ANY, "Libre Office: \n(Windows Only)")
		paths_sizer.Add(winlopath_label, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		paths_sizer.Add(self.winlopath, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		paths_sizer.Add(self.winlo_clear, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		paths_sizer.Add(self.winlo_browse, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		paths_sizer.Add(self.winlo_help, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		libnistpath_label = wx.StaticText(self.paths_panel, wx.ID_ANY, "LIB2NIST: ")
		paths_sizer.Add(libnistpath_label, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		paths_sizer.Add(self.libnistpath, 0, 0, 0)
		paths_sizer.Add(self.libnist_winlo_clear, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		paths_sizer.Add(self.libnist_browse, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		paths_sizer.Add(self.libnist_help, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		nistpath_label = wx.StaticText(self.paths_panel, wx.ID_ANY, "NIST MS Search: ")
		paths_sizer.Add(nistpath_label, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		paths_sizer.Add(self.nistpath, 0, 0, 0)
		paths_sizer.Add(self.nistpath_clear, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		paths_sizer.Add(self.nistpath_browse, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		paths_sizer.Add(self.nistpath_help, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		resultspath_label = wx.StaticText(self.paths_panel, wx.ID_ANY, "Results: ")
		paths_sizer.Add(resultspath_label, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		paths_sizer.Add(self.resultspath, 0, 0, 0)
		paths_sizer.Add(self.resultspath_clear, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		paths_sizer.Add(self.resultspath_browse, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		paths_sizer.Add((0, 0), 0, 0, 0)
		rawpath_label = wx.StaticText(self.paths_panel, wx.ID_ANY, ".RAW Files: ")
		paths_sizer.Add(rawpath_label, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		paths_sizer.Add(self.rawpath, 0, 0, 0)
		paths_sizer.Add(self.rawpath_clear, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		paths_sizer.Add(self.rawpath_browse, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		paths_sizer.Add((0, 0), 0, 0, 0)
		csvpath_label = wx.StaticText(self.paths_panel, wx.ID_ANY, "CSV Reports: ")
		paths_sizer.Add(csvpath_label, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		paths_sizer.Add(self.csvpath, 0, 0, 0)
		paths_sizer.Add(self.csvpath_clear, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		paths_sizer.Add(self.csvpath_browse, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		paths_sizer.Add((0, 0), 0, 0, 0)
		spectrapath_label = wx.StaticText(self.paths_panel, wx.ID_ANY, "CSV Spectra: ")
		paths_sizer.Add(spectrapath_label, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		paths_sizer.Add(self.spectrapath, 0, 0, 0)
		paths_sizer.Add(self.spectrapath_clear, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		paths_sizer.Add(self.spectrapath_browse, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		paths_sizer.Add((0, 0), 0, 0, 0)
		xypath_label = wx.StaticText(self.paths_panel, wx.ID_ANY, "XY Spectra: ")
		paths_sizer.Add(xypath_label, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		paths_sizer.Add(self.xypath, 0, 0, 0)
		paths_sizer.Add(self.xypath_clear, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		paths_sizer.Add(self.xypath_browse, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		paths_sizer.Add((0, 0), 0, 0, 0)
		msppath_label = wx.StaticText(self.paths_panel, wx.ID_ANY, "MSP Spectra: ")
		paths_sizer.Add(msppath_label, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		paths_sizer.Add(self.msppath, 0, 0, 0)
		paths_sizer.Add(self.msppath_clear, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		paths_sizer.Add(self.msppath_browse, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		paths_sizer.Add((0, 0), 0, 0, 0)
		expr_label = wx.StaticText(self.paths_panel, wx.ID_ANY, "Experiment Files:")
		paths_sizer.Add(expr_label, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		paths_sizer.Add(self.expr_path, 0, 0, 0)
		paths_sizer.Add(self.expr_clear, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		paths_sizer.Add(self.expr_browse, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		paths_sizer.Add((0, 0), 0, 0, 0)
		imagespath_label = wx.StaticText(self.paths_panel, wx.ID_ANY, "Spectra Images: ")
		paths_sizer.Add(imagespath_label, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		paths_sizer.Add(self.imagespath, 0, 0, 0)
		paths_sizer.Add(self.imagespath_clear, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		paths_sizer.Add(self.imagespath_browse, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		paths_sizer.Add((0, 0), 0, 0, 0)
		outputpath_label = wx.StaticText(self.paths_panel, wx.ID_ANY, "Raw Output: ")
		paths_sizer.Add(outputpath_label, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		paths_sizer.Add(self.outputpath, 0, 0, 0)
		paths_sizer.Add(self.outputpath_clear, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		paths_sizer.Add(self.outputpath_browse, 0, wx.ALIGN_CENTER_VERTICAL, 0)
		paths_sizer.Add((0, 0), 0, 0, 0)
		paths_sizer.Add((0, 0), 0, 0, 0)
		paths_sizer.Add((0, 0), 0, 0, 0)
		paths_sizer.Add((0, 0), 0, 0, 0)
		paths_sizer.Add((0, 0), 0, 0, 0)
		paths_sizer.Add((0, 0), 0, 0, 0)
		self.paths_panel.SetSizer(paths_sizer)
		paths_parent_sizer.Add(self.paths_panel, 5, wx.ALL | wx.EXPAND, 5)
		sizer_1.Add(self.paths_reset, 0, wx.ALIGN_BOTTOM | wx.ALIGN_RIGHT | wx.RIGHT, 9)
		self.reset_button_panel.SetSizer(sizer_1)
		paths_parent_sizer.Add(self.reset_button_panel, 1, wx.EXPAND, 0)
		self.prefs_panel.SetSizer(paths_parent_sizer)
		prefs_parent_sizer.Add(self.prefs_panel, 1, wx.ALL | wx.EXPAND, 10)
		self.SetSizer(prefs_parent_sizer)
		self.Layout()
		# end wxGlade

		self.btns = self.CreateSeparatedButtonSizer(wx.OK | wx.CANCEL)
		prefs_parent_sizer.Add(self.btns, 0, wx.ALL | wx.EXPAND, 5)
		self.SetMinSize((755,500))
		self.SetSize((755,500))

	def on_winlo_clear(self, event):  # wxGlade: paths_dialog.<event_handler>
		self.winlopath.Clear()
		event.Skip()

	def on_winlo_browse(self, event):  # wxGlade: paths_dialog.<event_handler>
		winlo_dlg = wx.DirDialog(None, "Choose a directory:",style=wx.DD_DEFAULT_STYLE | wx.DD_NEW_DIR_BUTTON)
		if winlo_dlg.ShowModal() == wx.ID_OK:
			self.winlopath.SetValue((winlo_dlg.GetPath()))
		winlo_dlg.Destroy()
		event.Skip()

	def on_winlo_help(self, event):  # wxGlade: paths_dialog.<event_handler>
		webbrowser.open("https://www.libreoffice.org/download/download/",2)
		event.Skip()

	def on_libnist_clear(self, event):  # wxGlade: paths_dialog.<event_handler>
		self.libnistpath.Clear()
		event.Skip()

	def on_libnist_browse(self, event):  # wxGlade: paths_dialog.<event_handler>
		libnistpath_dlg = wx.DirDialog(None, "Choose a directory:",style=wx.DD_DEFAULT_STYLE | wx.DD_NEW_DIR_BUTTON)
		if libnistpath_dlg.ShowModal() == wx.ID_OK:
			self.libnistpath.SetValue((libnistpath_dlg.GetPath()))
		libnistpath_dlg.Destroy()
		event.Skip()

	def on_libnist_help(self, event):  # wxGlade: paths_dialog.<event_handler>
		webbrowser.open("https://chemdata.nist.gov/mass-spc/ms-search/Library_conversion_tool.html",2)
		event.Skip()

	def on_nistpath_clear(self, event):  # wxGlade: paths_dialog.<event_handler>
		self.nistpath.Clear()
		event.Skip()

	def on_nistpath_browse(self, event):  # wxGlade: paths_dialog.<event_handler>
		nistpath_dlg = wx.DirDialog(None, "Choose a directory:",style=wx.DD_DEFAULT_STYLE | wx.DD_NEW_DIR_BUTTON)
		if nistpath_dlg.ShowModal() == wx.ID_OK:
			self.nistpath.SetValue((nistpath_dlg.GetPath()))
		nistpath_dlg.Destroy()
		event.Skip()

	def on_nistpath_help(self, event):  # wxGlade: paths_dialog.<event_handler>
		webbrowser.open("https://chemdata.nist.gov/mass-spc/ms-search/",2)
		event.Skip()

	def on_resultspath_clear(self, event):  # wxGlade: paths_dialog.<event_handler>
		self.resultspath.Clear()
		event.Skip()

	def on_resultspath_browse(self, event):  # wxGlade: paths_dialog.<event_handler>
		resultspath_dlg = wx.DirDialog(None, "Choose a directory:",style=wx.DD_DEFAULT_STYLE | wx.DD_NEW_DIR_BUTTON)
		if resultspath_dlg.ShowModal() == wx.ID_OK:
			self.resultspath.SetValue((resultspath_dlg.GetPath()))
		resultspath_dlg.Destroy()
		event.Skip()

	def on_rawpath_clear(self, event):  # wxGlade: paths_dialog.<event_handler>
		self.rawpath.Clear()
		event.Skip()

	def on_rawpath_browse(self, event):  # wxGlade: paths_dialog.<event_handler>
		rawpath_dlg = wx.DirDialog(None, "Choose a directory:",style=wx.DD_DEFAULT_STYLE | wx.DD_NEW_DIR_BUTTON, defaultPath=self.resultspath.GetValue())
		if rawpath_dlg.ShowModal() == wx.ID_OK:
			self.rawpath.SetValue((rawpath_dlg.GetPath()))
		rawpath_dlg.Destroy()
		event.Skip()

	def on_csvpath_clear(self, event):  # wxGlade: paths_dialog.<event_handler>
		self.csvpath.Clear()
		event.Skip()

	def on_csvpath_browse(self, event):  # wxGlade: paths_dialog.<event_handler>
		csvpath_dlg = wx.DirDialog(None, "Choose a directory:",style=wx.DD_DEFAULT_STYLE | wx.DD_NEW_DIR_BUTTON, defaultPath=self.resultspath.GetValue())
		if csvpath_dlg.ShowModal() == wx.ID_OK:
			self.csvpath.SetValue((csvpath_dlg.GetPath()))
		csvpath_dlg.Destroy()
		event.Skip()

	def on_spectrapath_clear(self, event):  # wxGlade: paths_dialog.<event_handler>
		self.spectrapath.Clear()
		event.Skip()

	def on_spectrapath_browse(self, event):  # wxGlade: paths_dialog.<event_handler>
		spectrapath_dlg = wx.DirDialog(None, "Choose a directory:",style=wx.DD_DEFAULT_STYLE | wx.DD_NEW_DIR_BUTTON, defaultPath=self.resultspath.GetValue())
		if spectrapath_dlg.ShowModal() == wx.ID_OK:
			self.spectrapath.SetValue((spectrapath_dlg.GetPath()))
		spectrapath_dlg.Destroy()
		event.Skip()

	def on_xypath_clear(self, event):  # wxGlade: paths_dialog.<event_handler>
		self.xypath.Clear()
		event.Skip()

	def on_xypath_browse(self, event):  # wxGlade: paths_dialog.<event_handler>
		xypath_dlg = wx.DirDialog(None, "Choose a directory:",style=wx.DD_DEFAULT_STYLE | wx.DD_NEW_DIR_BUTTON, defaultPath=self.resultspath.GetValue())
		if xypath_dlg.ShowModal() == wx.ID_OK:
			self.xypath.SetValue((xypath_dlg.GetPath()))
		xypath_dlg.Destroy()
		event.Skip()

	def on_msppath_clear(self, event):  # wxGlade: paths_dialog.<event_handler>
		self.msppath.Clear()
		event.Skip()

	def on_msppath_browse(self, event):  # wxGlade: paths_dialog.<event_handler>
		msppath_dlg = wx.DirDialog(None, "Choose a directory:",style=wx.DD_DEFAULT_STYLE | wx.DD_NEW_DIR_BUTTON, defaultPath=self.resultspath.GetValue())
		if msppath_dlg.ShowModal() == wx.ID_OK:
			self.msppath.SetValue((msppath_dlg.GetPath()))
		msppath_dlg.Destroy()
		event.Skip()
		
	def on_imagespath_clear(self, event):  # wxGlade: paths_dialog.<event_handler>
		self.imagespath.Clear()
		event.Skip()

	def on_imagespath_browse(self, event):  # wxGlade: paths_dialog.<event_handler>
		imagespath_dlg = wx.DirDialog(None, "Choose a directory:",style=wx.DD_DEFAULT_STYLE | wx.DD_NEW_DIR_BUTTON, defaultPath=self.resultspath.GetValue())
		if imagespath_dlg.ShowModal() == wx.ID_OK:
			self.imagespath.SetValue((imagespath_dlg.GetPath()))
		imagespath_dlg.Destroy()
		event.Skip()

	def on_outputpath_clear(self, event):  # wxGlade: paths_dialog.<event_handler>
		self.outputpath.Clear()
		event.Skip()

	def on_outputpath_browse(self, event):  # wxGlade: paths_dialog.<event_handler>
		outputpath_dlg = wx.DirDialog(None, "Choose a directory:",style=wx.DD_DEFAULT_STYLE | wx.DD_NEW_DIR_BUTTON, defaultPath=self.resultspath.GetValue())
		if outputpath_dlg.ShowModal() == wx.ID_OK:
			self.outputpath.SetValue((outputpath_dlg.GetPath()))
		outputpath_dlg.Destroy()
		event.Skip()

	def do_path_reset(self, event):  # wxGlade: paths_dialog.<event_handler>
		# Read the configuration from the file
		Config = ConfigParser.ConfigParser()
		Config.read("config.ini")
		self.winlopath.SetValue(relpath(Config.get("main", "winlopath"))) 
		if sys.platform == "win32":
			self.libnistpath.SetValue(relpath(Config.get("main", "libnistpath")))
			self.nistpath.SetValue(relpath(Config.get("main", "nistpath")))
		else:
			self.libnistpath.SetValue(relpath(Config.get("main", "linuxlibnistpath")))
			self.nistpath.SetValue(relpath(Config.get("main", "linuxnistpath")))
		self.resultspath.SetValue(relpath(Config.get("main", "resultspath")))
		self.rawpath.SetValue(relpath(Config.get("main", "rawpath")))
		self.csvpath.SetValue(relpath(Config.get("main", "csvpath")))
		self.spectrapath.SetValue(relpath(Config.get("main", "spectrapath")))
		self.xypath.SetValue(relpath(Config.get("main", "xypath")))
		self.msppath.SetValue(relpath(Config.get("main","msppath")))
		self.imagespath.SetValue(relpath(Config.get("main", "imagespath")))
		self.outputpath.SetValue(relpath(Config.get("main", "outputpath")))
		self.expr_path.SetValue(relpath(Config.get("main", "exprdir")))

	def on_expr_path_clear(self, event):  # wxGlade: paths_dialog.<event_handler>
		self.expr_path.Clear()
		event.Skip()
	def on_expr_path_browse(self, event):  # wxGlade: paths_dialog.<event_handler>
		expr_path_dlg = wx.DirDialog(None, "Choose a directory:",style=wx.DD_DEFAULT_STYLE | wx.DD_NEW_DIR_BUTTON, defaultPath=self.resultspath.GetValue())
		if expr_path_dlg.ShowModal() == wx.ID_OK:
			self.expr_path.SetValue((expr_path_dlg.GetPath()))
		expr_path_dlg.Destroy()
		event.Skip()
# end of class paths_dialog

class temp_new_dialog(wx.Dialog):
	def __init__(self, *args, **kwds):
		# begin wxGlade: temp_new_dialog.__init__
		kwds["style"] = kwds.get("style", 0) | wx.DEFAULT_DIALOG_STYLE | wx.RESIZE_BORDER
		wx.Dialog.__init__(self, *args, **kwds)
		self.paths_outer_panel = wx.Panel(self, wx.ID_ANY, style=wx.BORDER_RAISED)
		self.paths_inner_panel = wx.Panel(self.paths_outer_panel, wx.ID_ANY)
		self.paths_button = wx.Button(self.paths_inner_panel, wx.ID_ANY, "", style=wx.BU_AUTODRAW)
		self.import_raw_button.Bind(wx.EVT_SET_FOCUS, self.refresh_launcher)
		self.about_outer_panel = wx.Panel(self, wx.ID_ANY, style=wx.BORDER_RAISED)
		self.about_inner_panel = wx.Panel(self.about_outer_panel, wx.ID_ANY)
		self.about_button = wx.Button(self.about_inner_panel, wx.ID_ANY, "", style=wx.BU_AUTODRAW)
		self.import_raw_button.Bind(wx.EVT_SET_FOCUS, self.refresh_launcher)
		self.help_outer_panel = wx.Panel(self, wx.ID_ANY, style=wx.BORDER_RAISED)
		self.help_inner_panel = wx.Panel(self.help_outer_panel, wx.ID_ANY)
		self.help_button = wx.Button(self.help_inner_panel, wx.ID_ANY, "", style=wx.BU_AUTODRAW)
		self.import_raw_button.Bind(wx.EVT_SET_FOCUS, self.refresh_launcher)

		self.__set_properties()
		self.__do_layout()

		self.Bind(wx.EVT_BUTTON, self.on_import, self.paths_button)
		self.Bind(wx.EVT_BUTTON, self.on_import, self.about_button)
		self.Bind(wx.EVT_BUTTON, self.on_import, self.help_button)
		# end wxGlade

	def __set_properties(self):
		# begin wxGlade: temp_new_dialog.__set_properties
		self.SetTitle("multi_choice_dialog")
		_icon = wx.NullIcon
		_icon.CopyFromBitmap(wx.Bitmap("./lib/GunShotMatch logo256.png", wx.BITMAP_TYPE_ANY))
		self.SetIcon(_icon)
		self.paths_button.SetMinSize((64, 64))
		self.paths_button.SetToolTip("Import .RAW Files")
		self.paths_button.SetBitmap(wx.Bitmap("./icons/import.110.bmp", wx.BITMAP_TYPE_ANY))
		self.about_button.SetMinSize((64, 64))
		self.about_button.SetToolTip("Import .RAW Files")
		self.about_button.SetBitmap(wx.Bitmap("./icons/import.110.bmp", wx.BITMAP_TYPE_ANY))
		self.help_button.SetMinSize((64, 64))
		self.help_button.SetToolTip("Import .RAW Files")
		self.help_button.SetBitmap(wx.Bitmap("./icons/import.110.bmp", wx.BITMAP_TYPE_ANY))
		# end wxGlade

	def __do_layout(self):
		# begin wxGlade: temp_new_dialog.__do_layout
		launcher_right_sizer = wx.BoxSizer(wx.VERTICAL)
		help_outer_sizer = wx.BoxSizer(wx.VERTICAL)
		help_sizer = wx.BoxSizer(wx.VERTICAL)
		about_outer_sizer = wx.BoxSizer(wx.VERTICAL)
		about_sizer = wx.BoxSizer(wx.VERTICAL)
		paths_outer_sizer = wx.BoxSizer(wx.VERTICAL)
		paths_sizer = wx.BoxSizer(wx.VERTICAL)
		paths_sizer.Add(self.paths_button, 0, wx.ALIGN_CENTER, 64)
		paths_label = wx.StaticText(self.paths_inner_panel, wx.ID_ANY, "Configure\nPaths", style=wx.ALIGN_CENTER | wx.ALIGN_LEFT | wx.ST_NO_AUTORESIZE)
		paths_label.SetMinSize((256, 85))
		paths_sizer.Add(paths_label, 0, wx.ALIGN_CENTER, 64)
		self.paths_inner_panel.SetSizer(paths_sizer)
		paths_outer_sizer.Add(self.paths_inner_panel, 1, wx.ALIGN_CENTER | wx.ALL, 15)
		self.paths_outer_panel.SetSizer(paths_outer_sizer)
		launcher_right_sizer.Add(self.paths_outer_panel, 1, wx.ALL | wx.EXPAND, 5)
		about_sizer.Add(self.about_button, 0, wx.ALIGN_CENTER, 64)
		about_label = wx.StaticText(self.about_inner_panel, wx.ID_ANY, "About", style=wx.ALIGN_CENTER | wx.ALIGN_LEFT | wx.ST_NO_AUTORESIZE)
		about_label.SetMinSize((256, 85))
		about_sizer.Add(about_label, 0, wx.ALIGN_CENTER, 64)
		self.about_inner_panel.SetSizer(about_sizer)
		about_outer_sizer.Add(self.about_inner_panel, 1, wx.ALIGN_CENTER | wx.ALL, 15)
		self.about_outer_panel.SetSizer(about_outer_sizer)
		launcher_right_sizer.Add(self.about_outer_panel, 1, wx.ALL | wx.EXPAND, 5)
		help_sizer.Add(self.help_button, 0, wx.ALIGN_CENTER, 64)
		help_label = wx.StaticText(self.help_inner_panel, wx.ID_ANY, "Help", style=wx.ALIGN_CENTER | wx.ALIGN_LEFT | wx.ST_NO_AUTORESIZE)
		help_label.SetMinSize((256, 85))
		help_sizer.Add(help_label, 0, wx.ALIGN_CENTER, 64)
		self.help_inner_panel.SetSizer(help_sizer)
		help_outer_sizer.Add(self.help_inner_panel, 1, wx.ALIGN_CENTER | wx.ALL, 15)
		self.help_outer_panel.SetSizer(help_outer_sizer)
		launcher_right_sizer.Add(self.help_outer_panel, 1, wx.ALL | wx.EXPAND, 5)
		self.SetSizer(launcher_right_sizer)
		launcher_right_sizer.Fit(self)
		self.Layout()
		# end wxGlade

	def on_import(self, event):  # wxGlade: temp_new_dialog.<event_handler>
		print("Event handler 'on_import' not implemented!")
		event.Skip()
# end of class temp_new_dialog


				
# Statusbar and Importer Code
# Based on https://wiki.wxpython.org/Non-Blocking%20Gui
myEVT_STATUS = wx.NewEventType()
EVT_STATUS = wx.PyEventBinder(myEVT_STATUS, 1)
myEVT_CONVERSION = wx.NewEventType()
myEVT_CONVERSION_LOG = wx.NewEventType()
EVT_CONVERSION = wx.PyEventBinder(myEVT_CONVERSION, 1)
EVT_CONVERSION_LOG = wx.PyEventBinder(myEVT_CONVERSION_LOG, 1)

class StatusEvent(wx.PyCommandEvent):
	"""Event to signal that a new status is ready to be displayed"""
	def __init__(self, etype, eid, value=None):
		"""Creates the event object"""
		wx.PyCommandEvent.__init__(self, etype, eid)
		self._value = value

	def GetValue(self):
		"""Returns the value from the event.
		@return: the value of this event

		"""
		return self._value

kill_status_thread = False

class StatusThread(threading.Thread):
	# Includes code from https://gist.github.com/samarthbhargav/5a515a399f7113137331
	def __init__(self, parent, value):
		"""
		@param parent: The gui object that should recieve the value
		@param value: value to 'calculate' to
		"""
		self._stopevent = threading.Event( )
		threading.Thread.__init__(self, name="StatusThread")
		self._parent = parent
		self._value = value

	def run(self):
		"""Overrides Thread.run. Don't call this directly its called internally
		when you call Thread.start().
		"""
		wait_time = 1.0
		while not self._stopevent.isSet( ):
			time.sleep(0.1) # our simulated calculation time
			wait_time -= 0.1
			if wait_time < 0.0:
				evt = StatusEvent(myEVT_STATUS, -1, self._value)
				wx.PostEvent(self._parent, evt)
				wait_time = 1.0
			
	
	def join(self, timeout=None):
		""" Stop the thread and wait for it to end. """
		self._stopevent.set( )
		threading.Thread.join(self, timeout)		
		
		
	"""	global kill_status_thread
		try:
			while True:
				print(kill_status_thread)
				if kill_status_thread:
					break
				time.sleep(1) # our simulated calculation time
				evt = StatusEvent(myEVT_STATUS, -1, self._value)
				wx.PostEvent(self._parent, evt)
			print("Status Thread Exiting")
		except RuntimeError: 
			print("StatusThread Exiting")
			return
			# a runtime error was being raised when the main window closed"""
			


class MainThread(threading.Thread):
	def __init__(self, main_window, prefixList):
		threading.Thread.__init__(self)
		self.main_window = main_window
		

	def run(self):
		"""Overrides Thread.run. Don't call this directly its called internally
		when you call Thread.start().
		"""

		openLO = False
		
		logger = GSMatch.create_logger(args.verbose)
				
	#	import ConfigParser
		config = ConfigParser.ConfigParser()
		config.read("./lib/gsmatch.ini")
		
		last_config = config.get("MAIN","last_config")

		"""Set up GunShotMatch Class"""
		GSM = GSMatch.GunShotMatch("./config.ini")
				
		"""Set Samples"""
#		GSM.prefixList = 

		print("\nSamples to process: " + str(GSM.prefixList))
		
		"""Define Exit Functions"""
		atexit.register(GSMatch.final_cleanup,GSM.prefixList,GSM.OUTPUT_DIRECTORY, GSM.nist_path,GSM.lot_name)
		atexit.register(GSMatch.reload_ini, GSM.nist_path)

		# Autoprocess1
		if auto1:
			print("\nAutoprocess 1")
			GSM.doAuto1()
			
		# Autoprocess2
		elif auto2:
			print("\nAutoprocess 2")
			GSM.doAuto2()
			
		# Autoprocess3
		elif auto3:
			print("\nAutoprocess 3")
			GSM.doAuto3()
			
		else:
			# Run Combine
			if combine:
				print("\nCombine\n")
				GSM.doCombine()


			"""Run Spacer"""
			if space:
				print("\nSpace\n")
				GSM.doSpace()

			
			"""Run Merge"""
			"""This also runs Spacer"""
			if merge:
				print("\nMerge\n")
				GSM.doMerge()


			"""Open LibreOffice"""
			if openLO:
				GSM.do_open_lo()

				
			"""Run Jigsaw"""
			if jigsaw:
				GSM.doJigsaw()

				
			"""Run Counter"""
			if counter:
				print("\nCounter\n")
				if openLO:
					GSM.doCounter(seperator=",")
				else:
					GSM.doCounter()
				# need a way to detect seperator from file


		

		

		
		
				
		final_cleanup(GSM.prefixList,GSM.OUTPUT_DIRECTORY, GSM.nist_path, GSM.lot_name)
		print("\nComplete.")







		config = ConfigParser.ConfigParser()
		config.read("./lib/gsmatch.ini")
		last_config = config.get("MAIN","last_config")
		lib2nist_path, nist_path, LO_Path, CSV_DIRECTORY, OUTPUT_DIRECTORY, SPECTRA_DIRECTORY, XY_DIRECTORY, MSP_DIRECTORY, COMPARISON_DIRECTORY, RESULTS_DIRECTORY, auto1, auto2, auto3, prefixList = load_config(last_config)
		print("\nUsing configuration file {}".format(last_config))

			
		for prefix in prefixList:
			if prefix == "":
				prefixList.remove("")
		
		PL_len = len(prefixList)
		lot_name = re.sub(r'\d+', '', str(prefixList[0].rstrip("\n\r "))).replace("__","_")
		
		"""Define Exit Functions"""
		atexit.register(final_cleanup)
		atexit.register(reload_ini, nist_path)

		print("\nAutoprocess 3")
		auto = auto3

		if auto == ['']:
			auto = ["combine","merge","open_lo","counter"]
		
		if "combine" in auto:
			do_combine = True
		if "merge" in auto:
			do_merge = True
		if "open_lo" in auto:
			openLO = True
		if "jigsaw" in auto:
			do_jigsaw = True
		if "counter" in auto:
			args.counter = True
				
		print("Auto = " + str(auto))
		
		print("\nReady")
		print("Samples to process: " + str(prefixList))

		"""Run Combine"""
		if do_combine:# or (args.auto and "combine" in auto_1):
			print("\nCombine\n")
			for prefix in prefixList:
				GCMScombine(prefix.rstrip("\n\r ")) 

		"""Run Merge"""
		"""This also runs Spacer"""
		if do_merge:
			print("\nMerge\n")
			file_for_lo = Merge(prefixList)

		"""Open LibreOffice"""
		if openLO:
			open_lo(file_for_lo)
			
		"""Run Jigsaw"""
		if do_jigsaw:
			jigsaw()
			
		"""Run Counter"""
		if do_counter:
			print("\nCounter\n")
			Match_Counter(prefixList)
			make_archive()
				
		final_cleanup()
		print("\nComplete.")	

		# try:
			# import dummy
			
			# dummy.dummy(self.main_window)
		# except RuntimeError: 
			# pass # a runtime error was being raised when the main window closed

conversion_thread_running = False
main_thread_running = False

class ConversionEvent(wx.PyCommandEvent):
	"""Event to signal that a the conversion is complete"""
	def __init__(self, etype, eid):
		"""Creates the event object"""
		wx.PyCommandEvent.__init__(self, etype, eid)

	def GetValue(self):
		"""Returns the value from the event.
		@return: the value of this event

		"""
		return 0
		
class ConversionLogEvent(wx.PyCommandEvent):
	"""Event to signal that a the conversion is complete"""
	def __init__(self, etype, eid, log_text):
		"""Creates the event object"""
		wx.PyCommandEvent.__init__(self, etype, eid)
		self.log_text = log_text
		
	def GetValue(self):
		"""Returns the value from the event.
		@return: the value of this event

		"""
		return self.log_text
		
class ConversionThread(threading.Thread):
	def __init__(self, parent, file_list):
		"""
		@param parent: The gui object that should recieve the value
		@param value: value to 'calculate' to
		"""
		threading.Thread.__init__(self)
		self._parent = parent
		self.file_list = file_list
		

	def run(self):
		"""Overrides Thread.run. Don't call this directly its called internally
		when you call Thread.start().
		"""
		try:
			global conversion_thread_running
			conversion_thread_running = True
			
			# Read settings
			bb_points = int(self._parent.Config.get("import", "bb_points"))
			bb_scans = int(self._parent.Config.get("import", "bb_scans"))
			noise_thresh = int(self._parent.Config.get("import", "noise_thresh"))
			min_range, max_range = tuple(self._parent.Config.get("import", "target_range").split(","))
			target_range = (float(min_range),float(max_range))
			base_peak_filter = [int(x) for x in self._parent.Config.get("import", "exclude_ions").split(",")]
			#base_peak_filter = self._parent.Config.get("import", "exclude_ions")
			tophat_struct = "{}{}".format(self._parent.Config.get("import", "tophat"),self._parent.Config.get("import", "tophat_unit"))

			RESULTS_DIRECTORY = os.path.abspath(self._parent.Config.get("main","resultspath"))
			SPECTRA_DIRECTORY = os.path.abspath(self._parent.Config.get("main","spectrapath"))
			Expr_Path = os.path.abspath(self._parent.Config.get("main","exprdir"))
			raw_dir = os.path.abspath(self._parent.Config.get("main","rawpath"))
			
			if sys.platform == "win32":
				nist_path = self._parent.Config.get("main","nistpath")
			else:
				nist_path = self._parent.Config.get("main","linuxnistpath")
	
			for raw_file in self.file_list:
			#while False:
				# Convert RAW to JDX
				#os.system("wine ./lib/WatersRaw.exe -i {}".format(re.sub('[\[\],]', '', str(raw_list_with_dir))))
				process = subprocess.Popen(["wine","./lib/WatersRaw.exe","-i",os.path.join(raw_dir, raw_file)],stdout=subprocess.PIPE,stderr=subprocess.PIPE)
				#command = ["wine","./lib/WatersRaw.exe","-i"]
				#for raw_file in raw_list_with_dir:
				#	command.append(raw_file)
	#			process = subprocess.Popen(["wine","./lib/WatersRaw.exe","-i",",".join(raw_list_with_dir)],stdout=subprocess.PIPE)
			#	process = subprocess.Popen(command,stdout=subprocess.PIPE)
				#process = subprocess.Popen(["echo",re.sub('[\[\],]', '', str(raw_list_with_dir))],stdout=subprocess.PIPE)
				
				for line in iter(process.stdout.readline, b''):
						if not re.match(r'^\s*$', line.decode("utf-8")):# line is empty (has only the following: \t\n\r and whitespace)print(line.decode("utf-8"))
							evt = ConversionLogEvent(myEVT_CONVERSION_LOG, -1,log_text = line.decode("utf-8"))
							wx.PostEvent(self._parent, evt)
				
				
			#	import_processing(os.path.join(
			#		raw_dir, os.path.splitext(raw_file)[0]+".JDX"), 
			#		os.path.join(SPECTRA_DIRECTORY, os.path.splitext(raw_file)[0]+".new.csv"),
			#		os.path.join(RESULTS_DIRECTORY, os.path.splitext(raw_file)[0]+".new.csv"), 
			#		os.path.join(RESULTS_DIRECTORY, os.path.splitext(raw_file)[0]+"_combined.new.csv"), 
			#		bb_points, bb_scans, noise_thresh, target_range, gui=self._parent.import_log_text_control)
			
			
				args = ["python3", "-u", "./import_processing.py", "--infile", os.path.join(raw_dir, os.path.splitext(raw_file)[0]+".JDX"),
									"--spectrum", os.path.join(SPECTRA_DIRECTORY, os.path.splitext(raw_file)[0]+".new.csv"),
									"--report", os.path.join(RESULTS_DIRECTORY, os.path.splitext(raw_file)[0]+".new.csv"), 
									"--combined",os.path.join(RESULTS_DIRECTORY, os.path.splitext(raw_file)[0]+"_combined.new.csv"),
									"--bbpoints", str(bb_points), "--bbscans", str(bb_scans), "--noise_thresh", str(noise_thresh),
									"--target_range", str(target_range[0]), str(target_range[1]),
									"--tophat_struct", tophat_struct,
									"--nist_path", nist_path,
									"--expr_dir", Expr_Path,
									"--base_peak_filter",
									]
				
				for ion in base_peak_filter:
					args.append(str(ion))
			
				process = subprocess.Popen(args,
									stdout=subprocess.PIPE,
									stderr=subprocess.PIPE)			
				
			#	process = subprocess.Popen("python3 ./import_processing.py --infile " + os.path.join(raw_dir, os.path.splitext(raw_file)[0]+".JDX") + " --spectrum " + os.path.join(SPECTRA_DIRECTORY, os.path.splitext(raw_file)[0]+".new.csv") + " --report " + os.path.join(RESULTS_DIRECTORY, os.path.splitext(raw_file)[0]+".new.csv") + " --combined " + os.path.join(RESULTS_DIRECTORY, os.path.splitext(raw_file)[0]+"_combined.new.csv") + " --bbpoints " + str(bb_points) + " --bbscans " + str(bb_scans) + " --noise_thresh " + str(noise_thresh) + " --target_range " + str(target_range[0]) + " " + str(target_range[1]) + " --nist_path " + nist_path,stdout=subprocess.PIPE, shell=True)
				for line in iter(process.stdout.readline, b''):
					if not re.match(r'^\s*$', line.decode("utf-8")):# line is empty (has only the following: \t\n\r and whitespace)print(line.decode("utf-8"))
						if line != b'\r\x1b[K\n':
							#self._parent.import_log_text_control.AppendText(line.decode("utf-8"))
							evt = ConversionLogEvent(myEVT_CONVERSION_LOG, -1,log_text = line.decode("utf-8"))
							wx.PostEvent(self._parent, evt)	
				for line in iter(process.stderr.readline, b''):	
					if not re.match(r'^\s*$', line.decode("utf-8")):# line is empty (has only the following: \t\n\r and whitespace)print(line.decode("utf-8"))
						if line != b'\r\x1b[K\n':
							#self._parent.import_log_text_control.AppendText(line.decode("utf-8"))
							evt = ConversionLogEvent(myEVT_CONVERSION_LOG, -1,log_text = line.decode("utf-8"))
							wx.PostEvent(self._parent, evt)	
															
#			raw_list_with_dir = [os.path.join(raw_dir, rawfile) for rawfile in self.file_list]

							
			# Conversion is now done
			evt = ConversionLogEvent(myEVT_CONVERSION_LOG, -1,log_text = "Conversion Finished\n")
			wx.PostEvent(self._parent, evt)	
			
			# Send desktop notification
		#	notification.notification(header = "GunShotMatch", 
		#			body = 'Conversion finished\n'+", ".join(self.file_list),
		#			icon = "./lib/GunShotMatch.ico", duration = 5, threaded = True)

			NotificationMessage("GunShotMatch",
					message='Conversion finished\n'+", ".join(self.file_list),
					parent=None, flags=wx.ICON_INFORMATION).Show()

			conversion_thread_running = False
			evt = ConversionEvent(myEVT_CONVERSION, -1)
			wx.PostEvent(self._parent, evt)
		except: 
			traceback.print_exc()
			conversion_thread_running = False
			# a runtime error was being raised when the main window closed
			
			
class import_dialog(wx.Dialog):

	def __init__(self, *args, **kwds):
		# Content of this block not found. Did you rename this class?
		pass

	def __set_properties(self):
		# Content of this block not found. Did you rename this class?
		pass

	def __do_layout(self):
		# Content of this block not found. Did you rename this class?
		pass

# end of class import_dialog

# Constrain pan to x-axis
# From https://stackoverflow.com/questions/16705452/matplotlib-forcing-pan-zoom-to-constrain-to-x-axes
class My_Axes(matplotlib.axes.Axes):
	name = "My_Axes"
	def drag_pan(self, button, key, x, y):
		matplotlib.axes.Axes.drag_pan(self, button, 'x', x, y) # pretend key=='x'



class GSM_App(wx.App):
	def OnInit(self):
		self.frame = Launcher(None, wx.ID_ANY, "")
		self.SetTopWindow(self.frame)
		self.frame.Show()
		return True

# end of class GSM_App

if __name__ == "__main__":
	if sys.platform == "win32":
		import ctypes
		myappid = "GunShotMatchGUI"
		ctypes.windll.shell32.SetCurrentProcessExplicitAppUserModelID(myappid)
		
	GunShotMatch = GSM_App(0)
	GunShotMatch.MainLoop()

print("Goodbye :)")

sys.exit(0)
